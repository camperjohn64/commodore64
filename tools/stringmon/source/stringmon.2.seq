 .PAGE "STRINGMON.2";********************************;*                              *;* THIS ROUTINE  WILL LOAD FROM *;* A DEVICE, THE DEFAULT DEVICE *;* IS  EIGHT,  THE  DISK DRIVE. *;* THE OPTION FOR LOADING TO  A *;* NEW LOAD  ADDRESS  IS ADDED, *;* BY PUTING  A COMMA  AND  THE *;* NEW  LOAD  ADDRESS AFTER THE *;* FILE   NAME,  IF    NONE  IS *;* PUT  IT WILL  LOAD  FROM THE *;*     NORMAL LOAD ADDRESS      *;*                              *;* SYNTAX:.L "TEST"             *;*  ...OR:.L 09,"TEST"          *;*   ..OR:.L 08,"TEST",2000     *;*                              *;********************************;LOAD JSR GETNAM ; GET NAME AND DEVICE LDX #1 ; SET NORMAL LOAD FLAG STX TABLE+12 BCS NEWADR ; NEW LOAD ADDRESS... JSR OPENLD ; OPEN FILE FOR LOAD JSR PRTRET ; PRINT A RETURN JSR PSTART ;...THEN THE START ADDRESS JSR LOADLP ; NOW LOAD IT JSR FLIPTS JMP LDEND;NEWADR JSR DIGER2 ; GET NEW LOAD ADDRESS JSR PNTTMP ; PUT NEW ADDRESS IN TEMP2 JSR OPENLD ; OPEN YER FILE JSR NORML ; PRINT "NORMAL " JSR PSTART ; PRINT ADDRESS JSR PNTTMP ; RESTORE NEW ADDRESS JSR LOADLP ; THEN LOAD PROGRAM JSR NORML ; PRINT "NORMAL "... JSR ENDADR ; ..."END ADDRESS" LDA POINT2 ; CALCULATE NORMAL END ADDRESS LDY POINT2+1 SEC SBC POINT1 BCS NODECY ; CHECK FOR HIGH BYTE DEC DEYNODECY PHA ;...AND SAVE HERE TYA SEC ; SUBTRACT HIGH BYTE SBC POINT1+1 CLC ;...THEN ADD ORIGINAL ADDRESS ADC TEMP2+1 STA TEMP4 PLA ; RESTORE LOW BYTE CLC ADC TEMP2 BCC NOINC2 INC TEMP4NOINC2 PHA ; SAVE LOW BYTE LDA TEMP4 ;...THEN PRINT HIGH BYTE JSR PRTHEX PLA ; RETURN LOW BYTE JSR PRTHEX ;...AND PRINT IT JSR PRTRET JSR PSTART ; PRINT START ADDRESS JSR FLIPTSLDEND JSR PRTRET JSR ENDADR JSR PRTTWOPRTST AND #0 ; CLEAR ANY OUTPUT COMMAND STA TEMP5 JSR CLOSEF ; CLOSE FILE FIRST JMP PRSTAT ;...THEN PRINT DISK STATUS;PSTART JSR STRACT ; PRINT START ADDRESS .BYTE "START ADDRESS:",0 JMP PRTTWO;ENDADR JSR STRACT .BYTE "END ADDRESS  :",0 RTS;NORML JSR STROUT .BYTE 13,"NORMAL ",0 RTS;STRACT LDA TABLE+12 ; CHECK FOR NEED TO DO THIS BPL NACT JSR STROUT ; PRINT "ACTUAL" THING .BYTE "ACTUAL ",0NACT DEC TABLE+12 JMP STROUT;OPENLD AND #0 ; SET FOR CHANNEL 0 JSR OPENIT ; OPEN FILE JSR CHKIN ; .X=LOGICAL FILE JSR GET ; GET BYTE FROM DISK STA POINT1 JSR GET STA POINT1+1 LDA ST ; CHECK FOR STATUS ERRORS BNE PRTST RTS;LOADLP JSR PNT1T2 ; LOAD A PROGRAM FROM POINT1 JSR STOP ; CHECK FOR LOAD ABORTION BEQ RTS5LOADUP JSR GET LDY #0 JSR OUT ; FLIP ROMS OUT STA (POINT2),Y ; THEN STORE BYTE JSR IN LDA ST ; CHECK STATUS BNE RTS5 ;...FOR ANY ERRORS JSR STOP ; CHECK FOR STOP KEY BEQ RTS5 JSR INCPT2 ; INCREMENT POINTER JMP LOADUP ;...THEN CONTINUE WITH NEXT BYTE;OPENIT TAY ; A HOLDS CHANNEL LDA NUMCHR ; TEST IF NUMCHR IS ZERO BNE ITSANM ; MEANING NO FILENAME JMP ERROR;ITSANM LDA #DSKFIL ; OPEN FILE FOR LOAD/SAVE LDX MEMDEV JSR SETLFS ; SET FILE ADDRESSES LDA NUMCHR LDX #<NAME LDY #>NAME JSR SETNAM ;...THEN SET FILENAME JSR OPEN LDA ST ; CHECK FOR DEVICE PRESENT BMI NDEVC; LDX #DSKFILRTS5 RTS;CLOSEF JSR CLRCHN ; CLOSE DISK FILE LDA #DSKFIL JMP CLOSE;NDEVC JSR CLOSEF JMP NODEVC;;********************************;*                              *;* THE SAVE  COMMAND  WILL SAVE *;* TO A DEVICE FROM  TWO RANGES *;* IF YOU GIVE  A  THIRD RANGE, *;* THE LOAD ADDRESS WILL BE PUT *;*      AS THE EXTRA RANGE      *;*                              *;* SYNTAX:.S 8,"NAME",0801,1000 *;*  ...OR:.S 8,"NAME",0801,1000 *;*        ,2000                 *;*                              *;********************************;SAVE JSR GETNAM ; GET YER NAME AND DEVICE BCC ER14 ; NO SECOND ADDRESSES, ERROR JSR DIGER2 ; NOW GET START ADDRESS JSR FLIPTS ; SAVE ADDRESS JSR DIGERR ; THEN GET END ADDRESS JSR FLIPTS JSR MPNTMP ; PUT POINT1 TO TEMP2 JSR GETTWO ; GET NEXT RANGE IF ANY JSR PNTTMP ; FLIP NORMAL ADDR WITH NEW ADDR LDA #1 ; SET CHANNEL FOR WRITE JSR OPENIT ; OPEN FILE JSR CHKOUT LDA ST ; CHECK ERROR AFTER CHKOUT BNE SKPSAV LDA TEMP2 ; NO ERRORS, START SAVE JSR CHROUT ; FIRST SEND LOAD ADDRESS LDA TEMP2+1 JSR CHROUT JSR SAVELP ; THEN SAVE THE PROGRAMSKPSAV JMP PRTST ; PRINT DISK STATUS;SAVELP JSR STOP ; CHECK YER STOP KEY BEQ SAVEND ; IF ITS PRESSED, EXIT JSR OUT LDY #0 LDA (POINT1),Y ; GET BYTE OF PROGRAM JSR IN JSR CHROUT ;...AND PRINT IT TO THE DISK LDX ST ; DISK ERROR? BNE SAVEND ; YES, EXIT JSR INCPT1 ; INCREMENT POINTER JSR CHKEND ; CHECK IF IM DONE SAVING BCS SAVELP ;...AND CONTINUE WITH NEXT BYTE;SAVEND RTS;ER14 JMP ERROR;ILDECD JMP NODEVC ; REMOVE WHEN TAPE OPERATES;GETNAM LDY #0 ; GET FILENAME ROUTINE STY NUMCHR ; FILENAME LENGTH OF ZERO STY ST ; CLEAR STATUS JSR GETDAT ; GET FIRST CHARACTER BCC QDONE CMP #34 ; CHECK FOR BEGINING QUOTE BEQ DOQUTM ; NAME FIRST, GET NAME JSR GETHE2 ; GET NEW DEVICE BCC ER14 ; ERROR IF NONE CMP #4 ; CHECK FOR NON-SERIAL DEVICES BCC ILDECD CMP #33 BCS ILDECD STA MEMDEVWFQCC JSR GETDAT ; WAIT FOR QUOTE CHARACTER BCC QDONE CMP #34 BNE WFQCC;DOQUTM STA QUOTE ; TURN QUOTE MODE ONILOOP JSR GETDAT BCC SAVEND ; END OF LINE... CMP #34 ; NO, CHECK FOR ENDING QUOTE BEQ FINLCS STA NAME,Y INC NUMCHR ; INC LENGTH OF FILENAME INY BNE ILOOP ; ALWAYS...;FINLCS AND #0 ; KILL QUOTE MODE STA QUOTE JMP GETDAT ; GET NEXT CHARACTER;QDONE JMP DONE ; NO NAME AT ALL, EXIT TO DONE;PRTTWO LDA POINT1+1 ; PRINT TWO DIGITS FROM POINT1 JSR PRTHEX LDA POINT1;PRTHEX STY TEMP1 ; SAVE Y REGISTER LDX #2 LDY #4 ; 2 TIMES 4 SHIFTS BNE DOAAX;PRTBIN LDX #8 ; PRINT BINARY DIGIT LDY #1 ; 8 TIMES 1 SHIFT BNE DOAAX;PRTOCT LDX #4 ; PRINT OCTAL DIGIT IN A LDY #2 ; 4 TIMES 2 SHIFTSDOAAX STY CALNUM ; SAVE SHIFT NUMBERDOAAY LDY #0 ; CLEAR OUTPUT CHARACTER STY CALNUM+1 LDY CALNUM ; RETURN SHIFT NUMBERDOSHFT ASL A ; SHIFT DATA BYTE ROL CALNUM+1 DEY ; COUNT FOR ALL BITS IN SET BNE DOSHFT; PHA ; SAVE NEW SHIFTED BIT PATTERN LDA CALNUM+1 ; GET REMOVED BITS JSR CALCHR ; GET HIGH NYBBLE CHARACTER JSR PRINT ; PRINT IT... PLA ; RETURN NEXT BIT PATTERN DEX ; COUNT FOR ALL BITS BNE DOAAY; LDY TEMP1 RTS;TWOCHR PHA ; PRINT TWO CHARACTERS IN X,A TXA JSR PRINT PLA JMP PRINT;CALCHR ORA #"0" ; GET CHARACTER FROM A, A=0-16 CMP #":" ; GREATER THAN 10? (A-F) BCC NOADD ADC #6NOADD RTS;FLIPTS LDX #2 ; FLIP (POINT1) WITH (POINT2)FLOOP LDA POINT1-1,X PHA LDA POINT2-1,X STA POINT1-1,X PLA STA POINT2-1,X DEX BNE FLOOP; RTS ; X=0;GETTWO JSR GETHEX ; GET TWO DIGITS FOR (POINT1) BCS GOODT ; GOOD FIRST DIGIT, GET NEXT RTS;DIGER2 JSR GETHE2 ; GET DIGIT, FIRST CHAR IN .A JMP CO2;DIGERR JSR GETHEX ; GET DIGIT, ERROR IF NONECO2 BCC ER11GOODT LDA CALNUM+1 STA POINT1+1 LDA CALNUM ; SET LOW BYTE STA POINT1 AND #0 STA CALNUM+1 RTS;ER11 JMP ERROR;MPNTMP LDA POINT1 ; MOVE POINT1 TO TEMP2 LDY POINT1+1 STA TEMP2 STY TEMP2+1 RTS;OKMOM AND #0 ; CLEAR HIGH DECIMAL, GET LOW STA CALNUM+1 LDA CALNUM SEC ; SET FOR GOOD INPUT RTS;GETHEX LDA CALNUM+1 ; CHECK IF DECIMAL CALCUATED BNE OKMOM JSR GETDAT ; GET HEX DIGIT FOR .A BCC NSTSGETHE2 LDX #"+" ; RESET ADDITION FLAG STX POSNEG+1 JSR OOMPA ; CHECK END-OF-LINE STUFF BCC NSTSSKPDC CMP #34 ; CHECK FOR QUOTE BNE QCHECK; LDA QUOTE EOR #%11111111 ; SWITCH FROM/TO QUOTE MODE STA QUOTE; JSR GETDAT ; GET CHAR AFTER QUOTE BCS GETHE2 ; BRANCH IF ANY CHARACTER AT ALL RTS ; CARRY CLEAR IF END-OF-LINE;QCHECK LDX #0 ; CLEAR NUMBER STX CALNUM STX CALNUM+1 STX TEMP6 LDX QUOTE ; IN QUOTE MODE? BEQ ASOTES STA CALNUM ; SAVE FOR QUOTE MODE SEC ; SET CARRY TO SIGNAL GOOD BYTENSTS RTS;ASOTES JSR GETYPE ; SET INPUT TYPE BCC NSTS ; NO CHARACTER AFTER NEW SYMBOL BCS GETDEC ; SKIP FIRST INPUT;NXTDEC JSR INPUT ; GET SINGLE CHARACTERGETDEC CMP #"G" ; CHECK FOR VALID CHARACTER BCS SYNT CMP #"A" BCS OKCHA ; OK CHARACTER... CMP #":" BCS SYNT ; BAD CHARACTER CMP #"0" BCC SYNT ; BAD CHARACTEROKCHA INC TEMP6 ; SET CHARACTER GOTTON FLAG JSR GETNYB ; TURN INTO NYBBLE PHA ; SAVE BYTE LDY NMODE ; GET INPUT MODE CPY #3 ; DECIMAL? BEQ DPDECA ; YES, DO DECIMAL SHIFT LDA BASES,Y TAY ; SET SHIFT COUNTER PLA ; RETURN CHARACTER;NOFS ASL CALNUM ; SHIFT OVER DATA BYTE ROL CALNUM+1 DEY ; USING Y AS COUNTER BNE NOFS; ORA CALNUM ; MIX IN WITH OLD BITS STA CALNUM JMP NXTDEC;DPDECA LDA CALNUM ASL A ; MULTIPLY PREVIOUS NUMBER BY 10 ROL CALNUM+1 ; FIRST MULTIPLY CALNUM BY 2 STA CALNUM LDX CALNUM+1 ;...SAVE IT STX TEMP3 ASL A ; MULITPLY CALNUM BY 8 ROL CALNUM+1 ASL A ROL CALNUM+1 CLC ADC CALNUM ;...THEN ADD *2 AND *8 STA CALNUM BCC N INC CALNUM+1N LDA CALNUM+1 CLC ADC TEMP3 STA CALNUM+1 ;...RESULT IS CALNUM*2+CALNUM*8 PLA ; GET NEW CHARACTER CLC ADC CALNUM ; NOW ADD IN TO LAST NUMBER STA CALNUM BCC NXTDEC INC CALNUM+1 JMP NXTDEC;SYNT CMP #"+" ; CHECK FOR NUMBER ADDITION BEQ DOADA CMP #"-" ;...OR SUBTRACTION BNE NARARRDOADA TAX ; SAVE NEW SIGN LDA POSNEG+1 PHA ; PUSH OLD SIGN STX POSNEG+1 ; PUSH NEW SIGN LDA CALNUM ; PUSH VALUE PHA LDA CALNUM+1 ; PUSH HIGH BYTE PHA AND #0 STA CALNUM+1 JSR GETDAT ; PATCH FOR GETHEX BCC NFAT JSR SKPDC ; GETHEX MIGHT CALL SELF PLA ; RETURN OLD ADDRESS TAY ; HIGH BYTE IN .Y PLA TAX ; LOW BYTE IN .X PLA ; GET "+" OR "-"POSNEG CMP #"+" ; CHECK FOR CALNUM FLIP BEQ NFLIPC ; THE "+" IS THE ACTUAL FLAG STA POSNEG+1 LDA CALNUM EOR #%11111111 ; FLIP ALL BITS STA CALNUM LDA CALNUM+1 ; DO HIGH BYTE EOR #%11111111 ; FLIP ALL BITS STA CALNUM+1 INC CALNUM ; INC FOR FINAL XOR BNE NFLIPC INC CALNUM+1 ; INC HIGH BYTENFLIPC TXA ; NOW ADD ORIGINAL VALUE CLC ADC CALNUM ; ADD LOW BYTE FIRST STA CALNUM TYA ADC CALNUM+1 ; KEEP CARRY FROM LOW BYTE STA CALNUM+1 JMP NFAT;NARARR LDX TEMP6 ; CHECK FOR ANY CHARACTERS AT ALL BNE OKHS1 ; YES, OK VALUE JMP GETHEX ; NO, DO AGAIN;OKHS1 DEC TAB ; DEC TAB FOR PREVIOUS CHARACTER INC IO ; SET BIT FOR SCREEN INPUTNFAT LDA CALNUM+1 ; GET HIGH OR LOW BYTE BNE OKDAD ; OK FOR HIGH BYTE LDA CALNUM ; GET LOW BYTE THIS TIMEOKDAD SEC RTS;GETNYB CMP #":" ; GET SINGLE NYBBLE GIVEN A BCC ABCDEF ; IS IT A-F ADC #8ABCDEF AND #15 RTS;DECPT2 LDX #2 ; DECREMENT POINT2 .BYTE SKIP2;DECPT1 LDX #0 ; DECREMENT POINT1 LDY POINT1,X BNE NOADD1 ;...BY CHECKING FOR NULL BYTES LDY POINT1+1,X BNE NOADD2 INC TEMP4NOADD2 DEC POINT1+1,X; AND DECREMENTING THEMNOADD1 DEC POINT1,X RTS;GETDAT JSR INPUT ; SUB TO IGNORE SPACESOOMPA BIT QUOTE ; CHECK QUOTE FLAG BNE QTON CMP #" " ; QUOTE MODE OFF, IGNORE SPACES BEQ GETDAT CMP #":" ; COLONS ARE END-OF-LINE BEQ QRTS;QTON CMP #13 ; CHECK FOR A RETURN BEQ QRTS SEC ; NO, CARRY SET RTS;QRTS AND #0 ; CLEAR REVERSE MODE STA RVSFLG CLC ; RETURN PRESSED, CARRY CLEAR RTS;ERROR LDA #"?" ; EXIT BECAUSE OF ERROR JSR PRINT JMP DONE ;...AND RETURN TO DONE;NUMSPC JSR PRTSPC ; PRINT X NUMBER OF SPACES DEX BNE NUMSPC; RTS;INCPT2 INC POINT2 ; INCREMENT POINT2 BNE ARTS INC POINT2+1ARTS RTS;PNTTMP LDX POINT1 ; FLIP POINT1 WITH TEMP2 LDA TEMP2 STX TEMP2 STA POINT1 LDX POINT1+1 LDA TEMP2+1 STX TEMP2+1 STA POINT1+1; RTS; .IFE EXTRAS <PT2TP2 LDA POINT2+1 ; TEST POINT2 TO TEMP2 CMP TEMP2+1 BNE RTX LDA POINT2 ; TEST LOW BYTES CMP TEMP2RTX RTS;>CHKPO2 LDA POINT2 ; CHECK FOR POINT2-2 LDY POINT2+1 ; IS PAST POINT1 SEC SBC #2 BCS CKEND DEY BCC CKEND;CHKTMP LDA TEMP2 ; CHECK FOR TEMP2 IS PAST POINT1 LDY TEMP2+1 JMP CKEND;CHKEND LDA POINT2 ; CHECK IF POINT2 IS PAST LDY POINT2+1 ; POINT1CKEND SEC SBC POINT1 STA TEMP6 TYA SBC POINT1+1 TAY ORA TEMP6 ; CARRY CLEAR IF SO RTS;STROUT LDX POINT1 ; PRINT STRING ROUTINE LDY POINT1+1 ; SAVE POINTER FIRST STX TEMP3 STY TEMP4 PLA ; PULL RETURN ADDRESS STA POINT1 ;...AND USE AS POINTERS PLA STA POINT1+1 LDY #0OUTLP INC POINT1 ; INC POINTER BNE SKP1 INC POINT1+1SKP1 LDA (POINT1),Y ; WAS CHARACTER A ZERO? BEQ ENDSTR ; YES JSR PRINT ; NO, PRINT IT JMP OUTLP ; GET NEXT CHARACTER;ENDSTR LDA POINT1+1 ; PUT NEW RETURN ADDRESS BACK PHA LDA POINT1 PHA LDX TEMP3 ;...THEN RESTORE POINT1 LDY TEMP4 STX POINT1 STY POINT1+1 RTS;PNT1T2 LDA POINT1 ; MOVE POINT1 TO POINT2 LDY POINT1+1 STA POINT2 STY POINT2+1 RTS;GETYPE LDY #BASES-NTYPES-1;CHKNEW CMP NTYPES,Y ; CHECK FOR NEW INPUT TYPE BEQ NEWTYP DEY ; COUNT FOR NEXT MODE CHECK BPL CHKNEW; SEC RTS;NEWTYP STY NMODE ; SET NEW MODE AND #0 ; CLEAR CALNUM+1 STA CALNUM+1 JMP GETDAT ; GET NEXT DATA CHARACTER;NTYPES .BYTE "$%@/" ; HEX, BINARY, OCTAL, DECIMAL;BASES .BYTE 4,1,2 ; NUMBER OF SHIFTS PER DIGIT .IFE EXTRAS <GETPT1 LDA DCMODE ; CHECK IF IN DISK MODE BNE DOKSID LDA (POINT1),Y RTS;DOKSID STX TEMP7 ; SAVE Y INDEXERGETPX1 STY TEMP8 ; SAVE X INDEXER JSR IN ; FLIP ROM ROUTINES IN LDA MEMDEV ; TELL DEVICE TO LISTEN JSR LISTEN LDA #$FF ; SEND TO CHANNEL 15 JSR SALIST LDA #"M" ; SEND "M-R" COMMAND JSR OBYTE LDA #"-" JSR OBYTE LDA #"R" JSR OBYTE LDA POINT1 ; SEND LOCATION TO READ CLC ; DON'T FORGET TO ADD Y, (LOC),Y ADC TEMP8 PHP ; SAVE CARRY OF ADDITION JSR OBYTE LDA POINT1+1 PLP ; RETURN CARRY FROM LOW BYTE ADC #0 JSR OBYTE JSR UNLIST ; SEND COMMAND LDA MEMDEV ; INPUT BYTE JSR TALK ; TELL DEVICE TO TALK NOW LDA #$FF ; GET FROM CHANNEL 15 JSR SATALK JSR IBYTE ; GET THE BYTE NOW PHA ; SAVE IT JSR UNTALK ; SHUT DEVICE UP NOW JSR OUT PLA LDX TEMP7 LDY TEMP8 RTS ; WOW, WE'RE DONE;GETPT2 LDA DCMODE ; GET FROM (POINT2),Y BNE DODOXQ LDA (POINT2),Y RTS;DODOXQ STX TEMP7 ; GET FROM DISK, (POINT2),Y JSR FLIPTS ; REVERSE POINT2 WITH POINT1 JSR GETPX1 ; GET FROM POINT1, ER, POINT2 PHA JSR FLIPTS ; RETURN POINTERS TO NORMAL PLA ; RETURN BYTE LDX TEMP7 ; RETURN X AFTER "FLIPTS" RTS;PUTPT2 PHA ; PUT INTO (POINT2),Y LDA DCMODE ; CHECK IF GOING TO DISK BNE DLSDO ; YES... PLA ; NO, PUT INTO MEMORY STA (POINT2),Y RTS;DLSDO STX TEMP7 ; SAVE Y INDEXER PLAPUTPX2 STY TEMP8 ; SAVE X INDEXER JSR IN ; FLIP ROM ROUTINES IN PHA LDA MEMDEV ; SET OUTPUT DEVICE JSR LISTEN LDA #$FF ; SEND SA ADDRESS JSR SALIST LDA #"M" ; SEND "M-W" COMMAND JSR OBYTE LDA #"-" JSR OBYTE LDA #"W" JSR OBYTE LDA POINT2 ; SEND LOCATION TO WRITE CLC ; DON'T FORGET TO ADD Y, (LOC),Y ADC TEMP8 PHP ; SAVE CARRY OF ADDITION JSR OBYTE LDA POINT2+1 PLP ; RETURN CARRY FROM LOW BYTE ADC #0 JSR OBYTE LDA #1 ; SEND 1 BYTE JSR OBYTE PLA ; RETURN BYTE TO "POKE" JSR OBYTE JSR UNLIST JSR OUT LDX TEMP7 ; RETURN INDEXERS... LDY TEMP8 RTS;PUTPT1 PHA ; PUT AT (POINT1),Y LDA DCMODE ; CHECK IF IN DISK MODE BNE XWOWTT PLA STA (POINT1),Y ; PUT BYTE RTS;XWOWTT STX TEMP7 ; GET FROM DISK, (POINT2),Y JSR FLIPTS ; REVERSE POINT2 WITH POINT1 PLA JSR PUTPX2 ; PUT VALUE IN MEMORY JSR FLIPTS ; RETURN POINTERS TO NORMAL LDX TEMP7 ; RETURN X AFTER "FLIPTS" RTS;PRINT CMP #13 ; CHECK FOR PRINTING A RETURN BEQ PRINTX JMP PRINTA;PRINTX LDA PRMODE ; CHECK IF IN PRINTER MODE BNE PEORM ; YES, OUTPUT LINE TO PRINTER;XOPA1 LDA #13 ; NO, PRINT NORMAL RETURN JMP PRINTA;PEORM LDA TBLX ; CHECK IF DOING SAME LINE OVER CMP #24 ; ALWAYS PRINT ON LINE 24 BEQ XOPA2 CMP TEMPA BEQ XOPA1 ; DONE THIS ALREADY, EXIT .BYTE SKIP2 ; SKIP SUBTRACTXOPA2 SBC #1 STA TEMPA ; SET NEW LINE ADDRESS AND #0 ; CLEAT STATUS BYTE STA ST LDA PDEVC ; GET PRINTER DEVICE JSR LISTEN ; TELL IT TO LISTEN LDA #$70+0 ; SET CHANNEL 0 JSR SALIST LDA ST ; CHECK STATUS BYTE BPL OKDV JSR UNLIST AND #0 ; CLEAR PRMODE STA PRMODE JMP NODEVC ;...'CAUSE DEVICE NOT PRESENT;OKDV TYA PHA TXA PHA JSR OUTLN1 ; DO WHOLE THING IN ROUTINE BCC ABORTP CPY #1 ; SEE IF ONE CHARACTER TO OUTPUT BNE OUTIT DEY LDA (PNT),Y ; IS THAT ONE CHARACTER A "." CMP #"." BEQ ABORTP CMP #29 ; CHECK FOR "]" BEQ ABORTPOUTIT JSR AWSHITABORTP JSR UNLIST PLA ; RETURN .X AND .Y REGISTERS TAX PLA TAY LDA #13 ; RESTORE A WITH ORIGINAL 13 JMP PRINTA;OUTLN1 LDA #146 ; SET FLAG FOR NORMAL CHARACTERS STA FLAGCASE LDA #17 ; PUT PRINTER INTO LOWER CASE JSR OBYTE LDY MAXLIN ; FIND LENGTH OF LINEFINDLL LDA (PNT),Y CMP #" " ; CHECK IF A SPACE IF PRESENT BNE FNDMAX ; NO, FOUND LINE LENGTH DEY BPL FINDLL ; CHECK MORE CHARACTERS; CLC ; BLANK LINE, ABORT PRINTING RTS;FNDMAX INY ; INC PAST LAST CHARACTER STY TEMP7 ; SAVE LINE END SEC RTS;AWSHIT LDY #0 ; START SENDING LINE;SLIME STY TEMP8 LDA (PNT),Y PHA AND #%10000000 ; TURN CHAR INTO RVS CHAR EOR #%10000000 ORA #%00010010 CMP FLAG ; CHECK IF RVS MODE ALREADY ON BEQ TAKNCR ; RVS MODE TAKEN CARE OF... STA FLAG ; SET NEW FLAG JSR OBYTE ; SET REVERSE ON OR OFFTAKNCR PLA STA TEMP9 ; TURN INTO ASCII AND #%00111111 ASL TEMP9 BIT TEMP9 BPL LOP52 ORA #$80LOP52 BVS LOP54 ORA #$40LOP54 CMP #34 ; CHECK FOR A QUOTE BNE NOTWUT LDA #"'" ; SUBSTITUTE A FAKE QUOTENOTWUT JSR OBYTE LDY TEMP8 INY CPY TEMP7 ; CHECK IF DONE LINE BNE SLIME; LDA #13 ; PRINT RETURN AFTER LINE JMP OBYTE ;...TO PRINTER;> .FILE STRINGMON.3