 .PAGE "STRINGMON.4";*********************************;*                               *;* THIS COMMAND WILL DISASSEMBLE *;* A RANGE OF LINES, IF NO FIRST *;* RANGE IS GIVEN, IT WILL PRINT *;* FROM  THE LAST LINE  FROM THE *;* PREVIOUS  DISASSEMBLEY, IF NO *;* SECOND RANGE  IS GIVEN,  THIS *;* WILL  PRINT  UNTILL   END  OF *;* MEMORY IS REACHED,  ELSE THIS *;* WILL    DISASSEMBLE   BETWEEN *;*        THOSE  RANGES          *;*                               *;* SYNTAX:.D                     *;*  ...OR:.D 0800                *;*   ..OR:.D 0800 0900           *;*                               *;*********************************; .IFE EXTRAS <DISASM LDA #2 ; SET OMODE VALUE FOR INPUT STA OMODE JSR GTRANG ; GET DISASSEMBLEY RANGES> .IFN EXTRAS <DISASM JSR GTRANG ; GET DISASSEMBLEY RANGES> AND #0 STA TEMP2DLOOP JSR DIS ; DISASSEMBLE THIS LINE JSR ADDLEN ; ADD FOR NEXT INSTRUCTION CPY POINT1+1 ; TEST IF OVER $FFFF BCC GODODN STA POINT1 STY POINT1+1 JSR PAUSE ; CHECK SPACE BAR OR STOP KEY JSR CHKEND ; DONE RANGES YET... BCS DLOOP ; GUESS NOT, CONTINUE;GODODN JMP DONE> .IFE EXTRAS <DIS4 LDX SIGN ; NO RETURN FOR INPUT ROUTINE LDA #"," STA FLAG JSR TWOCHR JMP DIS3>;DIS LDY #","        ; DISASSEMBLE LINE FROM POINT1 .IFE EXTRAS < STY FLAG ; SET FOR NORMAL DISASSEMBLY> JSR PRTRDY ; PRINT RETURN, DOT, ","DIS3 JSR PRTSPC ; NOW A SPACE JSR PRTTWO ; PRINT ADDRESSESDIS2 JSR PRTSPC ; AND ANOTHER SPACE .IFE EXTRAS < LDX #2 ; SET OMODE STX OMODE> LDY #0 JSR OUT ; FLIP ROMS OUT .IFE EXTRAS < JSR GETPT1> .IFN EXTRAS < LDA (POINT1),Y ; GET ACTUAL BYTE> JSR IN ; FLIP ROMS BACK JSR FNDLGN ; GET INSTRUCTION LENGTH PHA ; SAVE CONVERTED OPCODE .IFE EXTRAS < LDA FLAG ; DO I PRINT CODE VALUES? BEQ NCODES> JSR PDIGTS ; PRINT HEX DIGITS OF OPCODENCODES LDX #3 ; OPCODES ARE 3 CHARACTERS LONG PLA ; RETURN CONVERTED OPCODE JSR OPCODE ; NOW PRINT IT LDX #6AD9C89 CPX #3 BNE AD9C9F LDY LENGTH BEQ AD9C9FAD9C91 LDA TEMP3 CMP #%11101000 JSR OUT .IFE EXTRAS < PHP ; SAVE PROCESSER FOR BCS DOFFST JSR GETPT1 PLP> .IFN EXTRAS < LDA (POINT1),Y> JSR IN BCS DOFFST JSR SEXY DEY BNE AD9C91;AD9C9F ASL TEMP3 BCC AD9CB1 LDA MODE1-1,X JSR CHKPRT LDA MODE2-1,X BEQ AD9CB1 JSR CHKPRTAD9CB1 DEX BNE AD9C89;CLREXT LDX TAB ; CLEAR ANY EXTRA CHARACTERS CPX #32 ;...'TILL TAB 31 BCS NOEX ; NO EXTRA STUFF TO KILL.. JSR PRTSPC JMP CLREXT;NOEX RTS;DOFFST JSR ADALEN ; DO A BRANCH, ADD A TO POINT1 TAX ; X NOW IS THE LOW BYTE INX ; INC ONCE FOR THE STUPID 6510 BNE NOINCY INY ;...INC HIGH BYTE IF NECESSARYNOINCY TYA ; PRINT HIGH BYTE JSR SEXY TXA ; NOW PRINT LOW BYTE... JSR SEXY ;...THEN THE HIGH BYTE JMP CLREXT;SEXY STX TEMP5 JSR PRTHEX LDX TEMP5 RTS;ADDLEN LDA LENGTH ; ADD LENGTH OF OPCODE TO POINT1 SECADALEN LDY POINT1+1 ; ADD A TO (DISLIN) TAX BPL NOYSC ; BUT IF A>128, SUBTRACT DEYNOYSC ADC POINT1 BCC INRTS INY ; Y=HIGH BYTEINRTS RTS;FNDLGN TAY ; FIND LENGTH OF OPCODE IN .A LSR A BCC CCDIS LSR A BCS NIEHAR CMP #%00100010 BEQ NIEHAR AND #%00000111 ORA #%10000000CCDIS LSR A TAX LDA GDOPS,X BCS STEPHA; LSR A LSR A LSR A LSR A;STEPHA AND #%00001111 BNE RISON;NIEHAR LDY #128 AND #0;RISON TAX LDA SPOPS,X STA TEMP3 AND #3 STA LENGTH TYA AND #%10001111 TAX TYA LDY #3 CPX #%10001010 BEQ ISSEXY;CATHY LSR A BCC ISSEXY; LSR A;CRAIG LSR A ORA #%00100000 DEY BNE CRAIG; INYISSEXY DEY BNE CATHY; RTS;PDIGTS TYA ; PRINT DIGITS BEFORE OPCODE TAX LDY #35 ; POKE ON COLON AT LINE END LDA #":" STA (PNT),Y LDA COLOUR ; PUT COLOUR IN AS WELL STA (COLPNT),Y TXA TAYPGIT LDX #1 ; SET BYTE INDEXER JSR OUT ; FLIP ROMS OUT TO GET BYTE .IFE EXTRAS < JSR GETPT1 ; GET BYTE> .IFN EXTRAS < LDA (POINT1),Y ; GET BYTE> JSR INGOTAB PHA ; SAVE BYTE STY LINE ; SAVE Y REGISTER TYA ; CALCULATE TAB CLC ADC #40-4 TAY LDA COLOUR ; POKE ON COLOUR STA (COLPNT),Y PLA ; RETURN CHARACTER STA (PNT),Y ; POKE ON CHARACTER LDY LINE ; RETURN Y REGISTER CPX #3 ; SKIP PRINTING NUMBERS... BEQ NPRITN ; YES... JSR SEXY ; PRINT ITNPRITN JSR NUMSPC ; NOW PRINT X NUMBER OF SPACES CPY LENGTH ; DONE ALL BYTES? INY BCC PGIT ;...NO, CONTINUE LDX #3 ; SET FOR 3 SPACES, " NN" LDA #" " ; SET TO POKE ON A SPACE CPY #4 ; CHECK FOR LAST NUMBER BCC GOTAB; JMP PRTCOL ; SEPARATE CODE FROM DIGITS;OPCODE TAY ; PRINT OPCODE GIVEN .A LDA LOWOPS,Y ; GET 16 BITS OF OPCODE STA TEMP2 LDA HIOPS,Y AND #%11111110 STA TEMP2+1NXTCHR AND #0 ; CLEAR .A FOR BITS TO FLOW INTO LDY #5 ; EACH CHARACTER IS 5 BITS LONGROLBIT ASL TEMP2+1 ; SHIFT BITS LEFT ROL TEMP2 ROL A ; LAST BIT GOES INTO .A DEY BNE ROLBIT ; ALL FIVE BITS INTO .A YET ADC #"?"        ; YES, TURN INTO ASCII JSR PRINT DEX BNE NXTCHR ; PRINT NEXT CHARACTERS BEQ PRTSPC;PRTCOL LDA #":"        ; PRINT A COLON .BYTE SKIP2PRTSPC LDA #" "        ; PRINT SPACE .BYTE SKIP2;PRTRET LDA #13 ; PRINT RETURN JMP PRINT;SET2FF LDA #$FF ; SET END-OF-MEMORY MARKER STA POINT1 STA POINT1+1 RTS;GTRANG JSR GETTWO ; GET DBYTE RANGES IF ANY BCC PRDIGT ; NO FIRST DIGIT JSR FLIPTS JSR GETDAT ; CHECK FOR SECOND ADDRESS BCC SET2MX AND #0 ; CLEAR CALNUM+1 FOR DECIMAL STA CALNUM+1 DEC TAB ; GO BACK ONE CHARACTER JSR GETTWO ; GET SECOND RANGE JMP FLIPTS;SET2MX JSR SET2FF ; SET MAXIMUM LINE JMP FLIPTS;PRDIGT JMP PRTTWO ; PRINT ADDRESS AFTER COMMAND;;****************************;*                          *;* THE COMMA WILL ENTER NEW *;* INTO      AN     ALREADY *;* DISASSEMBLED SCREEN, THE *;* COMMA  IS   AUTOMATICLEY *;* PRINTED AT THE SIDE WHEN *;*  DISASSEMBLING A SCREEN  *;*                          *;* SYNTAX:., 0800 AD 00 08  *;*                          *;****************************; .IFE EXTRAS <COMMA LDA #2 ; SET OMODE STA OMODE JSR GETTWO ; GET OLD ADDRESS> .IFN EXTRAS <COMMA JSR GETTWO ; GET OLD ADDRESS> BCC DONEITXCOMMA JSR PNT1T2 ; SAVE ADDRESS FOR DISASSEMBLEY LDA #70 ; MAX 70 NUMBERS INTO MEMORY STA LINECMLOOP JSR PUTBYT ; GET BYTE AND PUT IN MEMORY BCC REDIS BNE CMLOOP ; DONE ALL LOCATIONS YET?;REDIS JSR FLIPTS ; RESTORE LOCATION JMP REDISS;DONEIT JMP DONE;CHKPRT CMP TEMP2 BEQ RFS JMP PRINT;RFS RTS;DOUP LDA #145 ; GO TO PREVOIUS LINE JSR PRINT ;...BY PRINTING A CURSOR UPCLEART AND #0 ;...THE CLEARING THE TAB STA TAB RTS;;******************************;*                            *;* THIS IS A SIMPLE ASSEMBLER *;* THAT AFTER ASSEMBLING ONE  *;* LINE OF CODE, WILL PUT THE *;*    NEXT ADDRESS FOR YOU    *;*                            *;* SYNTAX:                    *;*                            *;* .A 0800 LDA ($5F),Y        *;* .A 0800 A9 00    :LDA #$00 *;*                            *;******************************;ASSM JSR GETTWO ; GET ADDRESS BCC DONEIT ; NO ADDRESS, PRINT ONE LDY TAB ; FIRST SCAN FOR COLONFNDCOL LDA (PNT),Y ; GET BYTE FROM SCREEN CMP #":" BEQ XCOMMA ; IF FOUND, INPUT NUMBERS BEFORE INY ; NOT HERE, KEEP TRYING CPY MAXLIN ; DON'T GO TO FAR EH! BCC FNDCOL; JSR FLIPTS ; SAVE POINTER STX POINT1 STX TABLE+1 LDX #3 ; GET THREE CHARACTERSGETUP JSR GETDAT BCS NRONE ; NO MORE DATA, EXIT JMP RDONE;NRONE PHA ;...AND PUT THEM ON THE STACK DEX BNE GETUP; LDX #3 ; NOW DECODE EACH CHARACTERROLNXT PLA SEC SBC #63 ; TURN 3 CHARACTERS INTO TWO LDY #5 ; FIVE BIT BYTESROLLIT LSR A ; SQUEZE BITS INTO "TABLE" ROR TABLE+1 ROR TABLE DEY ; BUT ONLY SHIFT FIVE BITS BNE ROLLIT; DEX ; COUNT FOR ALL CHARACTERS BNE ROLNXT; LDX #2 ; NOW GET ADDRESSING MODENXTADR JSR INPUT CMP #13 BEQ NOADDR ; CHECK FOR ADDRESSING DONE CMP #34 ; CHECK IF ITS A QUOTE BEQ ITSAQ LDY QUOTE ; CHECK IF WE'RE IN QUOTE MODE BNE QT ; YES, DON'T SKIP SPACES CMP #" " ; SKIP SPACES IF IN NORMAL MODE BEQ NXTADR; LDY #BASES-NTYPES-1;CWNEW CMP NTYPES,Y ; CHECK FOR NEW INPUT TYPE BEQ NINP DEY ; COUNT FOR NEXT MODE CHECK BPL CWNEW; BMI NONEW;NINP STY NMODE ; SET NEW MODE AND #0 ; CLEAR CALNUM+1 STA CALNUM+1 STA TABLE+19 ; CLEAR FLAG FOR DDINS LDA #"$" ; FAKE HEX INPUT STX TABLE+29 ; SAVE BEGINING OF NUMBER;NONEW JSR IF0TOF ; FIND IF ITS 0-F BCS NOT0TF ; NO, SAVE IN BUFFERQT STX TEMP5 ; SAVE X SOMEWHERE JSR GETHE2 ; TURN .A INTO HEX DIGIT LDX TEMP5 ; GET X BACK BCC NOADDR LDY CALNUM+1 ; CHECK FOR .WORD BEQ NDECW LDA #"0" ; PUT IN EXTRA ZEROS STA TABLE,X STA TABLE+1,X LDA CALNUM ; GET LOW BYTE OF .WORD INX INX ; INC TABLE INDEXER BNE YDECW ; ALWAYS;NDECW LDY POINT1 ; MOVE POINT1YDECW STY POINT1+1 STA POINT1 ;...SO DIGIT CAN GO THERE LDA #"0" ; SAVE TWO ZEROS IN THE BUFFER STA TABLE,X INX BNE NOT0TF ; ALWAYS...;ITSAQ LDA QUOTE EOR #%11111111 ; GO IN/OUT OF QUOTE MODE STA QUOTE BEQ NXTADR ; GO BACK, KEEP SAME .X; LDA #"$" ; INSERT FAKE HEX SIGN;NOT0TF STA TABLE,X INX BNE NXTADR ; ALWAYS;NOADDR STX TEMP2 ; SAVE END-OF-TABLE LDX #0 STX TEMP4 BEQ STSCAN ; ALWAYS;SCANIT INC TEMP4 BNE STSCAN BEQ IDONE ; OPCODE NOT FOUND;RDONE JSR FLIPTS ; NO DATA AFTER ADDRESS...IDONE JMP DONE;STSCAN LDX #0 ; CLEAR "TABLE" INDEXER STX LINE LDX TEMP3 STX TEMP2+1 LDA TEMP4 JSR FNDLGN ; CONVERT .A INTO INDEXER TAX LDY LOWOPS,X LDA HIOPS,X AND #%11111110 JSR TBLTWO ; COMPARE TABLE WITH OPCODE BNE SCANIT ; NOT THIS OPCODE, TRY NEXT ONE; CMP #0 ; SKIP ??? INSERT CHECKS BEQ SCANIT JSR DDINS ; INSERT MANDITORY ZEROS, EG JSR LDX #6 ; OPCODE FOUND, FIND OPERANDAD9E22 CPX #3 BNE NOMODE LDY LENGTH BEQ NOMODEAD9E2A LDA TEMP3 CMP #%11101000 ; CHECK IF ITS A BRANCH LDA #"0" BCS CALBEQ ; YES, CALCULATE A BRANCH JSR CHKTBL BNE SCANIT JSR LOOKTB BNE SCANIT DEY BNE AD9E2A;NOMODE ASL TEMP3 BCC ALMS LDY MODE2-1,X LDA MODE1-1,X JSR TBLTWO BNE SCANIT;ALMS DEX BNE AD9E22 BEQ AD9E5D;CALBEQ JSR CHKTBY ; CALCULATE A BRANCH BNE SCANIT ; CHECK FOR ZEROS IN TABLE JSR CHKTBY ; CHECK FOR ALL ZEROS "0000" BNE SCANIT ; IF NOT, EXITAD9E5D LDA TEMP2 CMP LINE BNE SCANIT JSR FLIPTS LDY LENGTH BEQ ILCC LDA TEMP3 CMP #%11101000 BCC ILOVE JSR CHKPO2 BCC AD9E7F TYA BNE GERROR LDA TEMP6 BPL SEXSEXGERROR JMP ERROR;AD9E7F INY BNE GERROR LDA TEMP6 BPL GERROR;SEXSEX LDY LENGTH BNE CATHYC;ILOVE LDA POINT1+1,YCATHYC JSR OUT .IFE EXTRAS < JSR PUTPT1> .IFN EXTRAS < STA (POINT1),Y> JSR IN DEY BNE ILOVE;ILCC LDA TEMP4 JSR OUT .IFE EXTRAS < JSR PUTPT1> .IFN EXTRAS < STA (POINT1),Y> JSR INREDISS JSR PRTRET ; CLEAR QUOTE MODE JSR DOUP ; BACKUP TO ORIGINAL LINE .IFE EXTRAS < LDX SIGN> .IFN EXTRAS < LDX #"." ; PRINT ".,"> LDA #"," STA FLAG ; SET FLAG FOR NUMBERS JSR TWOCHR JSR DIS3 ; REDISASSEMBLE THAT LINE JSR ADDLEN STA POINT1 STY POINT1+1 LDY #"A" ; NOW PRINT NEW ADDRESS JSR PRTRDY ; WITH RETURN, DOT, "A" JSR PRTSPC ; THEN PRINT A SPACE JSR PRTTWO ; PRINT DIGIT FROM (POINT1) JSR PRTSPC ; PRINT ANOTHER SPACE JSR DOUP SEI ; NO IRQ'S ALOWED NOW LDX #7 ; PRINT 8 CURSOR RIGHTS STX KEYLEN ; SET KEYBOURD LENGTH LDA #29 ; NOW SHOVE CURSOR RIGHTS INKEYIT STA KEYBUF,X DEX BPL KEYIT; CLI ; RE-ALLOW IRQ KEYBOARD SCAN JMP DONE;CHKTBY TAYTBLTWO JSR CHKTBL ; CHECK TABLE WITH OPS IN Y,A BNE NOTSAM ; FIRST TRY NOT GOOD TYA ; MAYBE, FALL THROUGH AND TRYCHKTBL BEQ NOTSAM ; CHARACTER=0, OKLOOKTB STX TEMP5 ; SAVE OPCODE INDEXER LDX LINE ; GET CURRENT TABLE INDEXER CMP TABLE,X ; COMPARE IT PHP ; DON'T LOOSE THE PROCESSER INX STX LINE ; INC FOR NEXT CHAR IN TABLE LDX TEMP5 PLPNOTSAM RTS;IF0TOF CMP #"0"        ; CHECK IF A IS FROM 0-F BCC NOTIN CMP #"G"        ; MAYBE, CARRY SET IF NOT RTS;NOTIN SEC RTS;DDINS LDX TABLE+19 ; CHECK IF ALREADY GONE THROUGH BNE NSPES ; YES, EXIT LDX TEMP5 ; CHECK HIGH BYTE NECESSITY LDA HIOPS,X LSR A ; SHIFT LOW BYTE INTO CARRY BCC NSPES ; NOT SET, HIGH BYTE UNNECESSARY LDA POINT1+1 BNE NSPES ; HIGH BYTE ALREADY IN... LDX TEMP4 ; CHECK FOR B6 OR A6 CPX #$A6 ; CHECK - LDX ZP BEQ NSPES ; DON'T ADD ZEROS, NO NEED 'EM CPX #$B6 ; CHECK - LDX ZP,Y BEQ NSPES ; EXIT BECAUSE OF PROGRAMME BUG LDX TEMP2 ; INSERT BYTE DEXINSTT LDA TABLE,X ; GET CHARACTERS STA TABLE+2,X ; INSERT TWO CHARACTERS DEX ; COUNT FOR NEXT CHARACTER CPX TABLE+29 ; CHECK IF DONE INSERT BNE INSTT; INC TEMP2 ; BUMP POINTER INC TEMP2 INC TABLE+19 ; SET FLAG FOR NEXT TIME;NSPES RTS;GDOPS .BYTE %01000000 .BYTE %00000010 .BYTE %01000101 .BYTE %00000011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %00110000 .BYTE %00100010 .BYTE %01000101 .BYTE %00110011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %01000000 .BYTE %00000010 .BYTE %01000101 .BYTE %00110011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %01000000 .BYTE %00000010 .BYTE %01000101 .BYTE %10110011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %00000000 .BYTE %00100010 .BYTE %01000100 .BYTE %00110011 .BYTE %11010000 .BYTE %10001100 .BYTE %01000100 .BYTE %00000000 .BYTE %00010001 .BYTE %00100010 .BYTE %01000100 .BYTE %00110011 .BYTE %11010000 .BYTE %10001100 .BYTE %01000100 .BYTE %10011010 .BYTE %00010000 .BYTE %00100010 .BYTE %01000100 .BYTE %00110011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %00010000 .BYTE %00100010 .BYTE %01000100 .BYTE %00110011 .BYTE %11010000 .BYTE %00001000 .BYTE %01000000 .BYTE %00001001 .BYTE %01100010 .BYTE %00010011 .BYTE %01111000 .BYTE %10101001;SPOPS .BYTE $00,$21,$81,$82 .BYTE $00,$00,$59,$4D .BYTE $91,$92,$86,$4A .BYTE $85,$9D;MODE1 .BYTE "," ; ; Y INDEXING COMMA ; ; LDA $0801,Y ; LDA ($00),Y... ; .BYTE ")" ; ; INDIRECT ADDRESSING BRACKET ; ; JMP ($0314) ; LDA ($00,X) ; LDA ($00),Y... ; .BYTE "," ; ; X INDEXING COMMA ; ; LDA $0801,X ; LDA ($00,X)... ; .BYTE "#" ; ; IMEDIATE ADDRESSING SYMBOL ; ; LDA #$00 ; AND #$80 ; EOR #$5A... ; .BYTE "(" ; ; CLOSING BRACKET ; ; JMP ($0314) ; LDA ($00,X) ; LDA ($00),Y... ; .BYTE "$" ; ; SIGN FOR ABSOULUTE ADDRESSING ; ; LDA $0801,Y ; LDA $00,X... ;MODE2 .BYTE "Y" ; ; Y INDEXING REGISTER ; ; LDA $0801,Y ; LDA ($00),Y... ; .BYTE 0 ; ; NULL AFTER CLOSING BRACKET ; ; JMP ($0314)@ ; LDA ($00,X)@ ; LDA ($00)@,Y... ; .BYTE "X" ; ; X INDEXING REGISTER ; ; LDA $0801,X ; LDA ($00,X)... ; .BYTE "$" ; ; IMEDIATE ADDRESSING HEX SIGN ; ; LDA #$00 ; AND #$80 ; EOR #$5A... ; .BYTE "$" ; ; INDIRECT ADDRESSING HEX SIGN ; ; JMP ($0314) ; LDA ($00,X) ; LDA ($00),Y... ; .BYTE 0 ; ; NULL BYTE AFTER ABSOULUTE ; ADDRESSING HEX SIGN ; ; LDA $@0801,Y ; LDA $@00,X... ;;; TWO BYTE EXPAND INTO THREE CHARACTERS;LOWOPS .BYTE %00011100 ; BRK .BYTE %10001010 ; PHP .BYTE %00011100 ; BPL .BYTE %00100011 ; CLC .BYTE %01011101 ; JSR .BYTE %10001011 ; PLP .BYTE %00011011 ; BMI .BYTE %10100001 ; SEC .BYTE %10011101 ; RTI .BYTE %10001010 ; PHA .BYTE %00011101 ; BVC .BYTE %00100011 ; CLI .BYTE %10011101 ; RTS .BYTE %10001011 ; PLA .BYTE %00011101 ; BVS .BYTE %10100001 ; SEI .BYTE %00000000 ; ??? .BYTE %00101001 ; DEY .BYTE %00011001 ; BCC .BYTE %10101110 ; TYA .BYTE %01101001 ; LDY .BYTE %10101000 ; TAY .BYTE %00011001 ; BCS .BYTE %00100011 ; CLV .BYTE %00100100 ; CPY .BYTE %01010011 ; INY .BYTE %00011011 ; BNE .BYTE %00100011 ; CLD .BYTE %00100100 ; CPX .BYTE %01010011 ; INX .BYTE %00011001 ; BEQ .BYTE %10100001 ; SED .BYTE %00000000 ; ??? .BYTE %00011010 ; BIT .BYTE %01011011 ; JMP NNNN .BYTE %01011011 ; JMP (NNNN) .BYTE %10100101 ; STY .BYTE %01101001 ; LDY .BYTE %00100100 ; CPY .BYTE %00100100 ; CPX .BYTE %10101110 ; TXA .BYTE %10101110 ; TXS .BYTE %10101000 ; TAX .BYTE %10101101 ; TSX .BYTE %00101001 ; DEX .BYTE %00000000 ; ??? .BYTE %01111100 ; NOP .BYTE %00000000 ; ??? .BYTE %00010101 ; ASL .BYTE %10011100 ; ROL .BYTE %01101101 ; LSR .BYTE %10011100 ; ROR .BYTE %10100101 ; STX .BYTE %01101001 ; LDX .BYTE %00101001 ; DEC .BYTE %01010011 ; INC .BYTE %10000100 ; ORA .BYTE %00010011 ; AND .BYTE %00110100 ; EOR .BYTE %00010001 ; ADC .BYTE %10100101 ; STA .BYTE %01101001 ; LDA .BYTE %00100011 ; CMP .BYTE %10100000 ; SBC;; BIT 0 IS  SET IF THE OPCODE;  MUST  HAVE TWO  BYTES IN;    THE ADDRESSING MODE;HIOPS .BYTE %11011000 ; BRK .BYTE %01100010 ; PHP .BYTE %01011011 ; BPL .BYTE %01001000 ; CLC .BYTE %00100111 ; JSR .BYTE %01100010 ; PLP .BYTE %10010101 ; BMI .BYTE %10001000 ; SEC .BYTE %01010100 ; RTI .BYTE %01000100 ; PHA .BYTE %11001001 ; BVC .BYTE %01010100 ; CLI .BYTE %01101000 ; RTS .BYTE %01000100 ; PLA .BYTE %11101001 ; BVS .BYTE %10010100 ; SEI .BYTE %00000000 ; ??? .BYTE %10110100 ; DEY .BYTE %00001001 ; BCC .BYTE %10000100 ; TYA .BYTE %01110100 ; LDY .BYTE %10110100 ; TAY .BYTE %00101001 ; BCS .BYTE %01101110 ; CLV .BYTE %01110100 ; CPY .BYTE %11110100 ; INY .BYTE %11001101 ; BNE .BYTE %01001010 ; CLD .BYTE %01110010 ; CPX .BYTE %11110010 ; INX .BYTE %10100101 ; BEQ .BYTE %10001010 ; SED .BYTE %00000000 ; ??? .BYTE %10101010 ; BIT .BYTE %10100011 ; JMP NNNN .BYTE %10100011 ; JMP (NNNN) .BYTE %01110100 ; STY .BYTE %01110100 ; LDY .BYTE %01110100 ; CPY .BYTE %01110010 ; CPX .BYTE %01000100 ; TXA .BYTE %01101000 ; TXS .BYTE %10110010 ; TAX .BYTE %00110010 ; TSX .BYTE %10110010 ; DEX .BYTE %00000000 ; ??? .BYTE %00100010 ; NOP .BYTE %00000000 ; ??? .BYTE %00011010 ; ASL .BYTE %00011010 ; ROL .BYTE %00100110 ; LSR .BYTE %00100110 ; ROR .BYTE %01110010 ; STX .BYTE %01110010 ; LDX .BYTE %10001000 ; DEC .BYTE %11001000 ; INC .BYTE %11000100 ; ORA .BYTE %11001010 ; AND .BYTE %00100110 ; EOR .BYTE %01001000 ; ADC .BYTE %01000100 ; STA .BYTE %01000100 ; LDA .BYTE %10100010 ; CMP .BYTE %11001000 ; SBC; .FILE STRINGMON.5