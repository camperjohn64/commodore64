 .PAGE "STRINGMON.5" .IFE EXTRAS <;****************************;*                          *;* THIS COMMAND IS LIKE THE *;* "GO"  COMMAND  BUT  WILL *;* SHOW  YOU THE LINE  THAT *;* IS  BEING  EXECUTED  AND *;* WAIT FOR YOU  TO PRESS A *;* KEY BEFORE  GOING TO THE *;*     NEXT INSTRUCTION     *;*                          *;* SYNTAX:.W FCE2           *;*  ...OR:.W                *;*                          *;****************************;WALK JSR GETTWO ; GET RANGE BCC NOPCHK ; ANY RANGE AT ALL? JSR SETPC ; YES, SAVE IT;NOPCHK JSR OUT ; NO, USE RANGE ALREADY IN PC JSR PRTPCX ; PRINT REGISTER DEFINITIONS AND #0 ; SET UP "." DEFINITIONS LDY #"." STA DCMODE STY SIGN LDA PCLO LDY PCHI LDX STACK ; SET STACK POINTER TXSWLOOP STA POINT1 STY POINT1+1 JSR PRTRET JSR FLIPTS ; SAVE POINT1 JSR DOREG ; PRINT COMMAND BEFORE EXECUTION JSR FLIPTS ; RESTORE POINT1 AND #0 STA FLAG ; FLAG FOR NUMBERS JSR DIS2 ; NOW DISASSEMBLE THE LINE;WAIT JSR STOP ; CHECK FOR STOP OR PAUSE BNE NSTOP JMP DONE;NSTOP JSR GET ; WAIT FOR A KEY TO BE PRESSED BEQ WAIT CMP #3 ; STOP KEY PRESSED? BEQ WAIT ; YES, STOP WALK; CMP #13 ; IS RETURN PRESSED? BNE NORET; LDX STACK TXS ; RESET STACK POINTER LDA #>RETURX ; IF SO, JSR TO THAT LOCATION PHA LDA #<RETURX PHA LDA PROCES PHA LDA AREG ; LOAD UP REGISTERS LDX XREG LDY YREG PLP JMP (POINT1) ; AFTER JMP...;;RETURN PHP ; CONTROL IS RETURNED TO HERE SEI ; SAVE GARBAGE STA AREG ; SAVE REGISTERS STX XREG STY YREG PLA STA PROCES PLA STA PCLO PLA STA PCHI AND #0 ; CLEAR LENGTH OF INSTRUCTION STA LENGTH ; ITS ALREADY PROCESSED BY JSR JMP CONT; RETURX=RETURN-1;SPEJMP JMP SPECAL;NORET LDY #0 ; EXECUTE COMMAND JSR OUT LDA (POINT1),Y JSR IN LDX #SPCEND-SPEBYT;SPLOOP CMP SPEBYT,X ; CHECK FOR BRANCHES OR JUMPS BEQ SPEJMP DEX BPL SPLOOP; LDX #2 ; NONE, EXECUTE COMMAND AS IS LDA #$EA ; NOP;CLEAR STA BUFFER,X ; CLEAR PREVIOUS INSTRUCTION DEX BPL CLEAR; LDY LENGTH ; GET LENGTH OF INSTRUCTION JSR OUT ; PLACE CURRENT ROM POSITION;PUTNEW LDA (POINT1),Y; PUT NEW INSTRUCTION IN STA BUFFER,Y DEY BPL PUTNEW; LDX STACK ; LOAD UP EVERYTHING TXS LDA PROCES PHA LDA AREG LDX XREG LDY YREG PLPBUFFER *=*+3 ; EXECUTION BUFFER PHP ; SAVE EVERYTHING STY YREG STX XREG STA AREG PLA STA PROCES TSX STX STACK LDA #%00110010 ; SET NORMAL PROCESSOR PHA PLPCONT SEI ; RESET IRQ LDA #<IRQ LDY #>IRQ STA IRQVEC STY IRQVEC+1 CLI JSR IN ; FLIP ROMS IN JSR PC2PNT ; RESTORE LOCATIONFINSPE JSR ADDLEN ; DO NEXT INSTRUCTIONSKPADD STA PCLO STY PCHI JMP WLOOP;SPECAL CPX #6 BCS BRANSH ; ANY COMMAND>5 IS A BRANCH TXA ; PERFORM SPECIAL COMMAND ASL A ; DOUBLE X FOR DBYTE .WORD TAX LDA SPEVEC+1,X PHA LDA SPEVEC,X PHAPC2PNT LDA PCLO LDY PCHI STA POINT1 STY POINT1+1 RTS;BRANSH LDA SPEBYT,X ; DO A BRANCH, GET BRANCH OPCODE STA INST ; SAVE FOR EXECUTION LDA PROCES PHA ; LOAD UP PROCESSER PLPINST BEQ BRANCH ;...AND BRANCH ACCORDINGLY JMP NOBEQ;BRANCH LDY #1 ; FAKE A BRANCH INSTRUCTION LDA (POINT1),Y BMI MINUS ; WHICH DIRECTION CLC ADC POINT1 ; ADD OFFSET BCC NOCARY INC POINT1+1;NOCARY STA POINT1NOBEQ LDA #%00110010 ; FALL THROUGH AND RETURN PHA ;...FIRST RESET STATUS PLP JMP FINSPE;MINUS AND #127 ; BRANCH BACKWARDS STA TEMP1 LDA #128 ; SUBTRACT TO FIND OFFSET SEC SBC TEMP1 STA TEMP1 ; OFFSET IS IN "TEMP1" NOW LDA POINT1 SBC TEMP1 ; CHECK FOR HI BYTE BCS NOCARY ; BRANCH OUT DEC POINT1+1 JMP NOCARY ; OR JUMP OUT;MOSJSR LDA POINT1 ; PERFORM A JSR OPCODE LDY POINT1+1 ; SET RETURN ADDRESS CLC ; ADD TWO BEFORE PUSHING ADC #2 BCC PUCKIT INYPUCKIT TAX ; SAVE LOW BYTE TYA ;...IN ORDER TO PUSH HIGH BYTE PHA TXA ; RESTORE LOW BYTE PHA ; PUSH IT DEC STACK ; DECREASE STACK POINTER DEC STACK ; THEN FALL THROUGH TO "JMP"MOSJMP LDY #1 ; JMPEXEJMP LDA (POINT1),Y; GET LOW BYTE TAX INY LDA (POINT1),Y ;...AND HIGH BYTE TAY ; TO BE STORFD IN "POINT1" TXA JMP SKPADD;MOSRTI PLA ; RTI STA PROCES ; PULL PROCESSER BEFORE INC STACK ; DOING A RTS PLA STA POINT1 PLA ; PULL BYTES OFF STACK STA POINT1+1 ; AND STORE IN "POINT1" INC STACK ; INCREASE STACK POINTER INC STACK JSR DECPT1 ; DEC FOR ABNORMAL 6510 JMP NOBEQ ; EXIT SPECIAL INSTRUCTION;MOSRTS PLA ; DO A RTS STA POINT1 PLA ; PULL RETURN ADDRESS OFF STACK STA POINT1+1 INC STACK ; MOVE STACK POINTER INC STACK JMP NOBEQ ; POINTER GETS BUMPED ON EXIT;INDJMP LDY #1 ; PERFORM AN INDIRECT JUMP LDA (POINT1),Y TAX INY LDA (POINT1),Y; GET FROM "POINT1" STA POINT1+1 ; AND RESTORE IN "POINT1" STX POINT1 LDY #0 BEQ EXEJMP ; ...THEN PERFORM "JMP";SPEVEC .WORD DONE-1 ; BRK .WORD MOSRTI-1 .WORD MOSRTS-1 .WORD MOSJSR-1 .WORD MOSJMP-1 .WORD INDJMP-1 ; INDIRECT JUMP;SPEBYT BRK ; SPECIAL COMMANDS THAT AFFECT RTI ; THE STACK OR PC ADDRESS RTS .BYTE $20 ; JSR .BYTE $4C ; JMP .BYTE $6C ; JMP ( ) .BYTE $10 ; BPL .BYTE $30 ; BMI .BYTE $50 ; BVC .BYTE $70 ; BVS .BYTE $90 ; BCC .BYTE $B0 ; BCS .BYTE $D0 ; BEQSPCEND .BYTE $F0 ; BNE;>;*****************************;*                           *;* DURING  NORMAL OPERATION, *;* STRINGMON WILL  RESET THE *;* BREAK VECTOR,  SO IT WILL *;* BE   LINKED   TO   NORMAL *;* COMPUTER   USE,  TO  KILL *;* STRINGMON,  USE  THE QUIT *;*          COMMAND          *;*                           *;* SYNTAX:.Q                 *;*                           *;*****************************;QUIT LDA JWARM+1 LDY JWARM+2 STA READY ; RESET WARM START VECTOR STY READY+1 LDA #<NORMAL ; AND BREAK VECTOR LDY #>NORMAL STA BREAK STY BREAK+1 .IFE LOC < LDA #<CSTART ; RESET BASIC POINTER LDY #>CSTART STA BASIC STY BASIC+1> .IFE LOC-1 < LDA #<MEMEND ; RESET END-OF-MEMORY POINTER LDY #>MEMEND STA BASEND STY BASEND+1> JMP EXIT ; EXIT TO BASIC;;******************************;*                            *;* THE  COMPARE  COMMAND WILL *;* COMPARE  TWO   BLOCKS   OF *;* MEMORY   (TO   LOOK  AT  A *;* PROGRAM  BEFORE  AND AFTER *;* IT HAS BEEN EXECUTED).THIS *;* WILL   PRINT    OUT    ALL *;* LOCATIONS THAT ARE NOT THE *;*           SAME             *;*                            *;* SYNTAX:.C 0800 0900 1000   *;*                            *;******************************;COMPAR JSR GETTWO ; GET FIRST LOCATION BCC ALDONE JSR FLIPTS ; DON'T LOOSE IT JSR DIGERR JSR INCPT1 ; ADD ONE EXTRA BYTE JSR PNTTMP ; SAVE IT HERE JSR DIGERR ; GET ADDRESS JSR GETDAT ; CHECK FOR END SYNTAX BCS ERROR2 LDA #13 JSR PRINT ; PRINT RETURN .IFE EXTRAS < LDA #16 ; SET COUNTER FOR LINE STA LINE> JSR OUT ; FLIP ROMS OUT;CLOOP LDA POINT2 ; CHECK FOR END OF COMPARE CMP TEMP2 BCC NOTYET LDA POINT2+1 ; HIGH BYTE CHECK CMP TEMP2+1 BCC NOTYET;ALDONE JMP DONE ; FINISHED COMPARE.;NOTYET LDY #0 .IFE EXTRAS < JSR GETPT1 ; GET FIRST VALUE STA TEMP1 ; SAVE FOR COMPARE JSR GETPT2 ; GET SECOND COMPARE VALUE CMP TEMP1 ; COMPARE THEM> .IFN EXTRAS < LDA (POINT1),Y ; COMPARE BYTES CMP (POINT2),Y> BEQ NOPRT ; DO I PRINT IT? JSR IN ; YES, GET READY TO PRINT JSR FLIPTS ; FLIP POINT1 WITH POINT2 JSR PRTTWO ; PRINT LOCATION JSR FLIPTS ; RETURN POINT1 WITH POINT2 .IFE EXTRAS < DEC LINE ; COUNT FOR RETURN BNE CNTCMP LDA #13 ; PRINT A RETURN JSR PRINT LDA #16 ; RESET COUNTER STA LINE BNE SKPSC;>CNTCMP JSR PRTSPC ; SPACES BETWEEN LOCATIONSSKPSC JSR PAUSE ; PAUSING BETWEEN NUMBERS JSR OUT ; REPLACE CURRENT ROM STATENOPRT JSR INCPT1 ; INC POINT1 JSR INCPT2 ; INC POINT2 JMP CLOOP ; DO AGAIN;ERROR2 JMP ERROR;PAUSE JSR GET ; PAUSE ROUTINE BEQ CHKSTP ; KEY PRESSED? CMP #" " ; IS IT SPACE? BNE CHKSTPSPCBAR JSR STOP ; IF SO, PAUSE BEQ ALDONE JSR GET CMP #" " ; WAIT FOR SPACE BAR AGAIN BNE SPCBAR RTS;CHKSTP JSR STOP ; CHECK FOR STOP KEY, BEQ ALDONE ; IF PRESSED, EXIT TO "DONE" RTS;;*******************************;*                             *;* OUTPUT  A  COMMAND  TO  THE *;* COMMAND     CHANNEL    THEN *;* RETURN  THE   DRIVE  STATUS *;* FROM ANY DEVICE NUMBER, THE *;*   DEFAULT DEVICE IS EIGHT   *;*                             *;* SYNTAX:.@ 09,"COMMAND"      *;*  ...OR:.@ "M-W",00,1C,01,04 *;*                             *;*******************************;STATUS AND #0 ; CLEAR COMMAND LENGTH STA TEMP5 JSR GETDAT ; GET DEVICE BCC PRSTAT ; NO DATA, JUST GET THE STATUS CMP #34 ; DO I USE THE DEFAULT DEVICE BEQ NOTDEV ; YES... JSR GETHE2 ; NO, GET HIS DEVICE NUMBER BCC PRSTAT STA MEMDEV AND #0 ; SET TO CLEAR QUOTE MODE .BYTE SKIP2;NOTDEV LDA #255 ; SET TO SET QUOTE MODE STA QUOTE JSR STRING ; GET COMMAND STRINGPRSTAT AND #0 ; CLEAR STATUS BYTE STA ST LDA MEMDEV ; COMMAND DEVICE TO LISTEN JSR LISTEN LDA #$F0+15 ;...TO CHANNEL 15 JSR SALIST LDA ST ; ANYBODY HOME? BMI O ; NO... LDA #13 ; PRINT RETURN JSR PRINT LDX #0 ; CLEAR COMMAND INDEXERSENDCM CPX TEMP5 ; CHECK IF DONE SENDING BEQ DNAJD LDA TABLE,X ; GET CHARACTER JSR OBYTE INX BNE SENDCM ; ALWAYS;DNAJD JSR UNLIST ; UNLISTEN DEVICE LDA MEMDEV ; TELL DEVICE TO TALK JSR TALK LDA #$F0+15 ;...TO CHANNEL 15 JSR SATALK JSR IBYTE ; INPUT BYTE FROM PORT CMP #13 ; CHECK FOR A RETURN BNE SKPGT ; PRINT CHARACTER, NOT A RETURNGETST JSR IBYTE ; NOW GET THE STATUS STRING CMP #13 BEQ NOTSTSKPGT JSR PRINTA ; PRINT CHARACTER TO SCREEN JMP GETST;NOTST JSR UNTALK ; SHUT DEVICE UP BEFORE EXIT JMP DONE;O JSR UNLIST ; BREAK LINK WITH DEVICENODEVC JSR STROUT .BYTE 13,"DEVICE NOT PRESENT",0 JMP DONE;;********************************;*                              *;* THIS COMMAND  WILL  PRINT  A *;* LOCATION   IN  HEX,   BINARY *;*       OCTAL OR DECIMAL       *;*                              *;* SYNTAX:.K C000               *;*                              *;********************************;CONVER JSR GETTWO ; GET STARTING LOCATION BCC DONIT ; NO FIRST RANGE, EXIT JSR PRTRET ; PRINT RETURN JSR PRTTWO ;...THEN PRINT IT LDA #"=" ; PRINT EQELS SIGN JSR PRINT LDA POINT1+1 ; NOW PRINT IT IN BINARY JSR PRTBIN LDA POINT1 ; PRINT LOW BYTE JSR PRTBIN LDA #"=" ; PRINT EQUALS SIGN JSR PRINT LDA POINT1+1 ; NOW PRINT IT IN OCTAL JSR PRTOCT LDA POINT1 ; PRINT LOW BYTE JSR PRTOCT LDA #"=" JSR PRINT LDA POINT1 LDX POINT1+1 JSR PRTDEC ; PRINT NUMBER IN DECIMALDONIT JMP DONE;;*******************************;*                             *;* THIS  DECIMAL  NUMBER PRINT *;* ROUTINE  WAS  MADE  BY  THE *;* RENOWNED  BOB CHAYTOR,  WHO *;* I GIVE GREAT THANKS TO, FOR *;* WITHOUT  HIS HELP,  I COULD *;*  NOT COMPLETE THIS PROGRAM  *;*                             *;*******************************;PRTDEC LDY #0 STY TEMP2 ; SET LEADING ZERO FLAG PHA ; SAVE LOW BYTE;LOOPT LDA #"0" ; GET SET TO OUTPUT "0" STA CALNUM PLA ; RETURN LOW BYTE;LOOPX STA TEMP1 ; SAVE IT TXA ; CHECK HIGH BYTE CMP HIGHS,Y PHP ; SAVE PROCESSOR LDA TEMP1 ; RESTORE LOW BYTE PLP ; RETURN PROCESSOR FROM CMP BCC EXY ; DIGIT CALCULATED, EXIT BNE AUTOSB CMP LOWS,Y ; MAYBE, CHECK LOW BYTE BCC EXY ; DIGIT CALCULATED, EXIT;AUTOSB SBC LOWS,Y ; NOT CALCULATED, SUBTRACT BASE PHA ; SAVE LOW BYTE NUMBER TXA ; SBC WITH HIGH BYTE SBC HIGHS,Y TAX PLA ; RETURN LOW BYTE INC CALNUM ; KEEP TRACK OF SBCS BNE LOOPX ; ALWAYS...;EXY INY ; PRINT CHARACTER, INY FOR NEXT PHA LDA CALNUM ; GET CALCULATED CHARACTER CMP #"0" ; CHECK IF A BEGINING ZERO... BNE PRA ; NO, PRINT IT AND SET FLAG CMP TEMP2 ; CHECK IF FLAG SET, A="0" BEQ PRA ; IN CASE TWO "0"S APPEAR, 4001 BCS NRA ; DON'T PRINT "0", LEADING ZEROPRA STA TEMP2 ; SET FLAG, USE CHARACTER DIGIT JSR PRINT ;...PRINT DIGITNRA CPY #5 ; CHECK IF ALL 5 DIGITS OUTPUT BNE LOOPT ; NO, CONTINUE; PLA ; RETURN EXTRA BYTE OFF STACK LDA #"0" ; CHECK FOR ANY # OUTPUT AT ALL CMP TEMP2 BCC OKOUTP ; CHARACTERS OUTPUT... BEQ OKOUTP ; CHARACTERS OUTPUT... JMP PRINT;OKOUTP RTS;HIGHS .BYTE >10000 ; HIGH BYTE DECIMALS .BYTE >1000 .BYTE >100 .BYTE >10 .BYTE >1;LOWS .BYTE <10000 ; LOW BYTE DECIMALS .BYTE <1000 .BYTE <100 .BYTE <10 .BYTE <1; .IFE EXTRAS <;****************************;*                          *;* THIS COMMAND INPUTS FROM *;* THE  DISK  DRIVE  MEMORY *;* AND   PUTS  IT  IN   THE *;* COMPUTERS  MEMORY.   THE *;* FIRST  TWO  NUMBERS  ARE *;* THE  LOCATIONS   TO  GET *;* FROM AND THE LAST NUMBER *;* IS THE ADDRESS TO PUT IT *;* IN THE  COMPUTERS MEMORY *;* ANOTHER NUMBER AFTER THE *;* DESTINATION NUMBER  WILL *;*   REPRESENT THE DEVICE   *;*                          *;* SYNTAX:.I 0400 0500 1000 *;*                          *;****************************;IND AND #0 ; SET INPUT FLAG .BYTE SKIP2;;****************************;*                          *;* THIS COMMAND OUTPUTS  TO *;* THE  DISK  DRIVE  MEMORY *;* FROM THE COMPUTER MEMORY *;* THE SYNTAX IS  THE  SAME *;* AS   THE  INPUT  COMMAND *;*                          *;* SYNTAX:.O 1000 1100 0400 *;*                          *;****************************;OUTD LDA #1 ; OUTPUT TO DISK DRIVE FLAG STA FLAG ; SAVE FLAG JSR DOREST ; INPUT ADDRESSES AND DEVICE;ILSTEF LDA MEMDEV ; COMMAND DEVICE TO LISTEN JSR LISTEN LDA #$F0+15 ;...TO CHANNEL 15 JSR SALIST LDA ST ; CHECK DEVICE BPL PLDFAS JSR UNLIST ; UNLISTEN DEVICE JMP NODEVC ; DEVICE NOT PRESENT ERROR;PLDFAS LDA #"M" ; PRINT "M-" FOR MEMORY COMMANDS JSR OBYTE LDA #"-" JSR OBYTE LDA FLAG ; CHECK FLAG TO MAKE SURE BEQ ITISIN LDA #"W" ; OUTPUT MODE... JSR OBYTE LDA POINT1 ; OUTPUT ADDRESS FOR BYTE JSR OBYTE LDA POINT1+1 JSR OBYTE LDA #1 ; ONE BYTE AT A TIME... JSR OBYTE LDY #0 ; CLEAR OFFSET INDEXER JSR OUT ; FLIP ROMS OUT... LDA (POINT2),Y JSR IN ; FLIP ROMS BACK IN JSR OBYTE JSR UNLIST JMP CONTD;ITISIN LDA #"R" ; INPUT MODE JSR OBYTE LDA POINT2 ; OUTPUT LOCATION TO READ JSR OBYTE LDA POINT2+1 JSR OBYTE JSR UNLIST ; SEND COMMAND LDA MEMDEV ; TELL DEVICE TO TALK JSR TALK LDA #$F0+15 ;...TO CHANNEL 15 JSR SATALK JSR IBYTE LDY #0 ; CLEAR OFFSET INDEXER JSR OUT STA (POINT1),Y JSR IN JSR UNTALK;CONTD JSR PT2TP2 ; CHECK END OF TRANSFER BNE XOTYET AND #0 ; CLEAR COMMAND LENGTH STA TEMP5 JMP PRSTAT ; THEN PRINT STATUS;XOTYET JSR INCPT1 ; INCREMENT POINTERS JSR INCPT2 JMP ILSTEF;ERAD2 JMP DONE;DOREST JSR GETTWO ; GET START LOCATION BCC ERAD2 JSR FLIPTS ; SAVE LOCATION JSR DIGERR ; GET END ADDRESS JSR PNTTMP ; SAVE IT IN TEMP2 JSR DIGERR ; GET LOCATION FOR STORAGE JSR GETHEX ; GET NEW DEVICE IF ANY BCC NNDECV ; NONE... STA MEMDEVNNDECV JSR PT2TP2 ; CHECK FOR RANGE CONFLICT BCS ERAD2 RTS;;********************;*                  *;* MODE SET ROUTINE *;* FOR  "." AND "]" *;*                  *;********************;SETD LDA #1 ; SET DRIVE MODE... LDX #"]" ; CHANGE INPUT PROMT SIGN BNE QWERU;SETC AND #0 ; SET COMPUTER MODE LDX #"." ; CHANGE INPUT PROMT SIGNQWERU STA DCMODE STX SIGN STX QUOTE ; SET QUOTE FLAG FOR ":" COMMAND JMP HERTIT ; NOT DONE, CONTINE COMMAND LINE;;********************;*                  *;* SET   MAP   UNIT *;* WITH THE  U SIGN *;*                  *;* SYNTAX:.U 08     *;*                  *;********************;SETDV JSR GETHEX ; GET DEVICE... BCC NDK ; NO NUMBER... STA MEMDEV ; NUMBER THERE, SET DEVICENDK JMP DONE;;********************;*                  *;* TURN ON  PRINTER *;* AND SET P DEVICE *;* THE   UPPER   OR *;* LOWER CASE  MODE *;* CHARACTER    CAN *;* BE  INPUT  AFTER *;*    THE DEVICE    *;*                  *;* SYNTAX:.P 04     *;*  ...OR:.P 05U    *;*  ...OR:.P 04D    *;*                  *;********************;PRINTL JSR GETHEX ; GET PRINTER DEVICE BCC NDRX STA PDEVC ; SET PRINTER DEVICE JSR GETDAT ; GET NEXT CHARACTER BCC NSOD LDY #17 ; SET FOR LOWER CASE CMP #"L" ; CHECK MODE BEQ DOSTAQ LDY #145 ; SET FOR UPPER CASE CMP #"U" BNE NSODDOSTAQ STY CASE+1 ; SAVE CASENSOD LDX #13 ; PRINT RETURN FIRST LDA SIGN STA QUOTE JSR TWOCHR LDA #1 ; TURN PRINTER ON STA PRMODE AND #0 ; SET STUFF THAT HERTIT DOESN'T STA NMODE ;...LIKE HEX INPUT STA CALNUM+1 ;...AND HIGH BYTE INPUT JMP HERTIT;NDRX AND #0 ; NO DATA, KILL PRINTER STA PRMODE JMP DONE; .BYTE ">>BY JOHN MCCARTHY<<"> .IFN EXTRAS < .BYTE "JSM" ; JUST GOTTA GET THAT IN THERE>;COMNDS .BYTE ":;RMGXLSTFHD,A" .IFE EXTRAS < .BYTE "QC@E>KWIO].UP*"> .IFN EXTRAS < .BYTE "QC@E>K">;VECTOR .WORD COLON-1 ; : .WORD SEMI-1 ; ; .WORD PRINTR-1 ; R .WORD MEMORY-1 ; M .WORD GO-1 ; G .WORD EXIT-1 ; X .WORD LOAD-1 ; L .WORD SAVE-1 ; S .WORD TRANS-1 ; T .WORD FILL-1 ; F .WORD HUNT-1 ; H .WORD DISASM-1 ; D .WORD COMMA-1 ; , .WORD ASSM-1 ; A .WORD QUIT-1 ; Q .WORD COMPAR-1 ; C .WORD STATUS-1 ; @ .WORD ECOM-1 ; E .WORD WEDGE-1 ; > .WORD CONVER-1 ; K .IFE EXTRAS < .WORD WALK-1 ; W .WORD IND-1 ; I .WORD OUTD-1 ; O .WORD SETD-1 ; ] .WORD SETC-1 ; . .WORD SETDV-1 ; U .WORD PRINTL-1 ; P .WORD LOADO-1 ; *;TABS .BYTE 0,0,0,0,0 ; TABS FOR NEW EDITOR .BYTE 0,0,0,0,0CRSFLG .BYTE 1 ; FLAG FOR CURSOR KEYSDELFLG .BYTE 1 ; FLAG FOR BLACKHOLE DELETEOMODE .BYTE 0 ; OUTPUT FOR SCROLLING EDITORSIGN .BYTE "." ; SIGN FOR PROMT, "." OR "]"PDEVC .BYTE 4 ; PRINTER DEVICEDCMODE .BYTE 0 ; DRIVE/COMPUTER MAPPING MODE> .IFN EXTRAS <;>MEMDEV .BYTE 8 ; DEFAULT DEVICE, GETS MODIFIED;TEMP1 *=*+1 ; TEMPORARY STORAGE SHITTEMP2 *=*+2TEMP3 *=*+1TEMP4 *=*+1TEMP5 *=*+1TEMP6 *=*+1 .IFE EXTRAS <TEMP7 *=*+1TEMP8 *=*+1TEMP9 *=*+1TEMPA *=*+1>CALNUM *=*+2 ; NUMBER CALCULATOR FOR INPUTFLAG *=*+1 ; DISASSEMBLY FLAGLINE *=*+1 ; CURRENT LINE FOR MAP COMMANDLENGTH *=*+1 ; LENGTH OF DISASSEMBLED OPCODEPCHI *=*+1 ; REGISTER STORAGEPCLO *=*+1PROCES *=*+1 ; PROCESSOR STATUS BYTEAREG *=*+1XREG *=*+1YREG *=*+1STACK *=*+1 ; STACK POINTERR6510 *=*+1 ; CURRENT ROM IN/OUT STATELAST *=*+1TABLE *=*+24 ; TABLE FOR FILL AND HUNTNAME *=*+24 ; FILENAME STORED HERENUMCHR *=*+1 ; LENGTH OF FILENAMEQUOTE *=*+1 ; QUOTE MODE FLAG (ZERO=OFF)NMODE *=*+1 ; NUMERIC INPUT MODE, $%@/ .IFE EXTRAS <TAB2 *=*+1 ; SAVED TAB LOCATIONOLDFLG *=*+1 ; USED BY NEW INPUT ROUTINEPRMODE *=*+1 ; PRINTER ACTIVATION FLAG>; .IFE LOC < .BYTE 0ENDPRG .BYTE 0,0 ; BASIC PROGRAMS START HERE;> .LIST .END