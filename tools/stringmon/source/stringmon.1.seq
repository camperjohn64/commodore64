; .IFE EXTRAS < CRSRDN=17 ; CURSOR DOWN KEY CRSRUP=145 ; CURSOR UP KEY SHRUN=131 ; SHIFT RUN DELKEY=20 ; DELETE KEY F1=133 ; FUNCTION KEY DEFINITIONS F3=F1+1 F5=F3+1 F7=F5+1 F2=F7+1 F4=F2+1 F6=F4+1 F8=F6+1;> SKIP1=$24 ; SKIP 1 BYTE BIT COMMAND SKIP2=$2C ; SKIP 2 BYTES BIT COMMAND DSKFIL=100 ; DISK LOGICAL FILE NUMBER; ROMS=1 ; NORMAL ROM SWITCH LOCATION ST=$90 ; DEVICE STATUS POINT1=$22 ; POINTERS... POINT2=POINT1+2 SCREEN=POINT2+2 KEYLEN=$C6 ; LENGTH OF KEYBOARD BUFFFER RVSFLG=$C7 ; EDITOR IN REVERSE MODE, 1=YES INDX=$C8 LXSP=$C9 BLNSW=$CC ; FLASH CURSOR, 0=NO, 1=YES GDBLN=$CE BLNON=$CF ; CURSOR FLASHED, 0=NO, 1=YES IO=$D0 ; INPUT FROM SCREEN/KEYBOURD PNT=$D1 ; ROM POINTER TO SCREEN TAB=$D3 ; CURRENT CURSOR TAB QTSW=$D4 MAXLIN=$D5 ; CURRENT SCREEN LINE LENGTH TBLX=$D6 TDAT3=$D7 INSRT=$D8 LDTB1=$D9 COLPNT=$F3 ; POINTER TO COLOUR RAM KEYBUF=$0277 ; KEYBOURD BUFFER COLOUR=$0286 ; CURRENT CURSOR COLOUR GDCOL=$0287 HIBASE=$0288 AUTODN=$0292 AC=$030C ; BASIC'S ACCUMULATOR XR=AC+1 ; BASIC'S .X REGISTER YR=XR+1 ; BASIC'S .Y REGISTER SP=YR+1 ; BASIC'S STATUS REGISTER READY=$0302 ; WARM START VECTOR IRQVEC=$0314 ; IRQ VECTOR BREAK=$0316 ; BREAK VECTOR BASVEC=$A002 ; BASIC WARM START HARD VECTOR STUPT=$E56C LP2=$E5B4 LOP5=$E63A CLP2=$E65D FINDST=$E6ED PRINT2=$E71D ; PRINT NORMAL CHARACTER NMLDEL=$E750 ; NORMAL DELETE KEY SCROL=$E8EA BMTLA=$E968 DSPP=$EA13 SCOLOR=$EA24 IRQ=$EA31 ; NORMAL IRQ VECTOR NORMAL=$FE66 ; NORMAL BREAK VECTOR ADDRESS .IFN EXTRAS < INPUT=$F15B ; INPUT A STRING OF CHARACTERS PRINT=$E716 ; PRINT TO SCREEN> PRINTA=$E716 ; PRINT TO SCREEN STOP=$F6ED ; CHECK STOP KEY GET=$F13E ; GET FROM KEYBOURD OPEN=$F351 ; OPEN LOGICAL FILE CLOSE=$F291 ; CLOSE LOGICAL FILE CLRCHN=$F333 ; CLEAR CHANNEL CHKOUT=$F250 ; SET FOR OUTPUT CHKIN=$F20E ; SET FOR INPUT SETLFS=$FE00 ; SET LFS ADDRESSES SETNAM=$FDF9 ; SET NAME CHROUT=$F1CA ; SEND CHARACTER BY OPEN FILE TALK=$ED09 ; TELL SERIAL DEVICE TO TALK LISTEN=$ED0C ; TELL SERIAL DEVICE TO LISTEN UNTALK=$EDEF ; TELL DEVICE TO UNTALK UNLIST=$EDFE ; TELL DEVICE TO UNLISTEN SATALK=$EDC7 ; SEND SA AFTER TALK SALIST=$EDB9 ; SEND SA AFTER LISTEN IBYTE=$EE13 ; INPUT BYTE FROM SERIAL PORT OBYTE=$EDDD ; OUTPUT BYTE TO SERIAL PORT;;******************************;*                            *;*    DETERMINE START CODE    *;*                            *;******************************; *=CODE; .IFE LOC < BASIC=$2B ; START OF BASIC PROGRAM;CSTART .BYTE 14,8,10,0 .BYTE 158," (2064)",0,0,0; BSUB2=*+2; LDA #VERSON ; SET VERSION NUMBER LDA #<ENDPRG+1 ; BUMP UP BASIC CODE POINTER LDY #>ENDPRG CPY BASIC+1 ; CHECK IF ALREADY DONE THAT... BNE CHKBMP CMP BASIC ; BY COMPARING DBYTE POINTERCHKBMP BCC START STA BASIC ; NOT SET, SET POINTER STY BASIC+1 ;...THEN FALL THROUGH TO MONITER> .IFE LOC-1 < MEMEND=$A000 ; NORMAL LIMIT-OF-MEMORY BASEND=$37 ; END OF BASIC POINTER BSUB2=*+2;STARTC LDA #VERSON LDA #<STARTC ;...MUST BE SET BACK LDY #>STARTC ; FOR MONITER TO FIT CPY BASEND+1 ; CHECK FOR ALREADY SET BACK BNE CHKSTB CMP BASENDCHKSTB BCS START STA BASEND STY BASEND+1 ; FALL THROUGH TO MONITER> .IFE LOC-2 < BSUB2=*+2 ; NO CODE FOR THIS LOC; LDA #VERSON>;;******************************;*                            *;*        CALL ADDRESS        *;*                            *;******************************;START LDA READY ; GET NORMAL WARM START VECTOR LDY READY+1 CPY #>REBRK ; CHECK IF ALREADY CALLED BNE ENABLE CMP #<REBRK ; MAYBE, CHECK HIGH BYTE BEQ NRESETENABLE STA JWARM+1 ; SAVE NORMAL VECTOR STY JWARM+2 LDA #<REBRK LDY #>REBRK STA READY ; SET NEW WARM START VECTOR STY READY+1NRESET LDA #<BRKVEC ; SET BREAK VECTOR LDY #>BRKVEC STA BREAK STY BREAK+1ALLANX LDA #"C" ; SET FOR "CALL" STA CHR+1 LDA #>BSUB2 ; NOW FAKE A BRK PHA ; PUSH HIGH BYTE ADDRESS LDA #<BSUB2 ;...AND LOW BYTE ADDRESS PHA LDA SP ; NORMAL STATUS PHA ; SAVE IT LDA AC ; LOAD UP REGISTERS PHA LDA XR ; FROM BASIC PHA LDA YR PHA ; FALL THROUGH TO MONITER;BRKVEC CLD ; BREAK VECTOR JSR IN PLA ; GET ALL REGISTERS OFF STACK STA YREG ; SAVE THEM IN THE RUGHT PLACES PLA STA XREG PLA STA AREG PLA ; SAVE PROCESSER STA PROCES PLA ; NOW GET WHERE PC CAME FROM TAX PLA TAY TXA SEC SBC #2 ; FIND CORRECT LOCATION STA PCLO TYA SBC #0 ; ALSO DEC HIGH BYTE STA PCHI TSX STX STACK .IFE EXTRAS < AND #0 ; CLEAR PRINTER MODE STA PRMODE> JSR PRTRETCHR LDX #"B" ; PRINT "B*" FOR "BREAK" LDA #"*" JSR TWOCHR LDA #"B" ; RESET TO "BREAK", AFTER "CALL" STA CHR+1 LDA #"R" ; PERFORM "REGISTER" COMMAND BNE CHKCOM ; JUMP TO "PERFORM COMMAND";INCPT1 INC POINT1 ; INC (POINT1) BNE IRTS INC POINT1+1 BNE IRTS INC TEMP4 ; INC TEMP4 IF OVER $FFFFIRTS RTS;NGET13 JSR GETDAT ; GET CHARACTER, CURSOR FLASHES BCS IRTS ; ONLY CURSOR FLASHING INPUT;DONE LDX #248 ; FALL THROUGH IF TXS ; "END OF INPUT LINE" IS FOUND AND #0 ; RETURNS TO HERE AFTER COMMAND STA TEMP4 STA NMODE ; SET FOR HEX INPUT STA CALNUM+1 .IFE EXTRAS < STA ST ; CLEAR ST FOR DISK ACCESS> JSR CHKEND ; TEST FOR RANGE ERROR BEQ DOSETF BCS REINADOSETF LDA #$FF STA POINT2 ; SET MAXIMUM RANGE STA POINT2+1REINA LDX #13 ; PRINT RETURN .IFE EXTRAS < LDA SIGN ; PRINT CURRENT SIGN> .IFN EXTRAS < LDA #"." ;...AND "." STA QUOTE ; SET QUOTE FOR "GETDAT"> JSR TWOCHR .IFE EXTRAS <HERTIT LDA DCMODE ; CHECK TO CHECK DEVICE PRESENT BEQ REINPT ; NO...; LDA MEMDEV ; CHECK FOR DEVICE PRESENT JSR LISTEN ; TELL DEVICE TO LISTEN LDA #$FF ; SEND TO CHANNEL 15 JSR SALIST LDA ST PHA ; SAVE STATUS BYTE JSR UNLIST ; UNLISTEN DEVICE PLA BPL REINPT ; DISK DRIVE PRESENT... AND #0 ; SET TO "." MODE LDY #"." STA DCMODE ; SET DCMODE STY SIGN ; RESTORE "." SIGN JMP NODEVC ; PRINT "DEVICE NOT...";>REINPT JSR NGET13 ; INPUT WAIT .IFN EXTRAS < CMP #"." ; DID YOU MOVE UP OR DOWN? BEQ REINPT> CMP #" " ; IGNORE SPACES, GETDAT DOESN'T BEQ REINPT; LDX #0 STX QUOTE ; NOW CLEAR QUOTE MODE;CHKCOM LDX #VECTOR-COMNDS-1AGAIN CMP COMNDS,X ; CHECK FOR COMMAND BNE NOTCOM; TXA ; JUMP TO COMMAND ASL A ; MULTIPLY FOR TWO BYTE ADDRESS TAX LDA VECTOR+1,X ; AND SHOVE STUFF ON STACK PHA LDA VECTOR,X PHA RTS;NOTCOM DEX ; NEXT COMMAND BPL AGAIN ; CHECK FOR MORE COMMANDS; JMP ERROR ; ERROR IF NOT CORRECT COMMAND;SETPC LDA POINT1 ; PUT (POINT1) INTO PCLO AND PCHI STA PCLO LDA POINT1+1 STA PCHI RTS;MEMLIN LDA #8 ; PRINT 8 LOCATIONS ROUTINE STA LINE ; PRINT .A LOCATIONS ROUTINEMEMLOP LDY #0 ;...FROM (POINT1) JSR PRTSPC ; PRINT SPACE FIRST JSR OUT ; ROMS OUT .IFE EXTRAS < JSR GETPT1 ; GET BYTE> .IFN EXTRAS < LDA (POINT1),Y ; GET BYTE> JSR IN ; SHOVE ROMS IN PHA JSR PRTHEX ; NOW PRINT IT PLA JSR CHARS ; PUT SCREEN CODES JSR INCPT1 ; INC POINTER DEC LINE ; DONE YET? BNE MEMLOP;CLRTAB LDX TAB ; YES, CLEAR EXTRA SPACES CPX #30 BCS WRTN JSR PRTSPC JMP CLRTAB;PUTBYT JSR GETHEX ; PUT BYTE INTO MEMORY BCC WRTN LDY #0 JSR OUT ; FLIP ROMS OUT .IFE EXTRAS < JSR PUTPT1> .IFN EXTRAS < STA (POINT1),Y> JSR IN ; FLIP ROMS IN JSR INCPT1 ; INC POINT1 DEC LINE ; CHECK FOR LAST ENTRY SEC ; DATA WAS GOOD, SET CARRYWRTN RTS;PRTRDY TYA ; PRINT RETURN, "." AND .Y PHA JSR PRTRET PLA .IFE EXTRAS < LDX SIGN> .IFN EXTRAS < LDX #"."> JMP TWOCHR ; SIMPLE BUT USEFULL ROUTINE;;************************;*                      *;* THIS IS THE REGISTER *;* COMMAND   THAT  WILL *;* LIST  OUT  ALL  YOUR *;* REGISTERS, PROCESSOR *;* STATUS,  ACCUMULATOR *;* X  REGISTER,  THE  Y *;* REGISTER,  AND STACK *;*       POINTER        *;*                      *;* SYNTAX:.R            *;*                      *;************************;PRINTR JSR PRTPCX ; PRINT REGISTER DEFINITIONS JSR PRTRET JSR DOREG ; PRINT YER LINEREREG LDA PCLO ; SET POINT1 DEFAULT TO PC ADDR LDY PCHI STA POINT1 STY POINT1+1 JMP DONE;PRTPCX JSR STROUT .BYTE 13,"   PC  NVXBDIZC AC XR YR SP",0 RTS;DOREG LDA #";" ; PRINT ";" SYMBOL LDX #"." ; ALWAYS COMPUTER REGISTERS... JSR TWOCHR LDA PCHI ; PRINT ADDRESS JSR PRTHEX LDA PCLO JSR PRTHEX JSR PRTSPC ; LEAVE A SPACE LDA PROCES JSR PRTBIN ; NOW PRINT STATUS IN BINARY LDY #0 ; CLEAR REGISTER INDEXER;REGLOP JSR PRTSPC ; SPACES BETWEEN REGISTERS LDA AREG,Y ; GET A REGISTER JSR PRTHEX ;...NOW PRINT IT INY ; INCREMENT INDEXER CPY #4 BNE REGLOP; RTS;;***************************;*                         *;* THIS IS THE  MEMORY MAP *;* COMMAND THAT MAPS EIGHT *;* LOCATIONS AT A TIME AND *;* PRINTS   THERE   SCREEN *;* CODES ON THE RIGHT HAND *;*   SIDE OF THE SCREEN    *;*                         *;* SYNTAX:.M 0800 0900     *;*                         *;***************************; .IFE EXTRAS <MEMORY AND #0 ; SET OMODE STA OMODE JSR GTRANG ; GET ADDRESS RANGES> .IFN EXTRAS <MEMORY JSR GTRANG ; GET ADDRESS RANGES>MLOOP JSR PAUSE ; CHECK FOR STOP OR PAUSE LDX TEMP4 BNE JMPDON ; GONE OVER $FFFF?; JSR CHKEND ; COMPARE LOCATIONS BCC JMPDON ; CHECK FOR LAST LOCATION; LDY #":"        ;...NOW PRINT LINE JSR PRTRDY ; PRINT ":" FIRST JSR ML2 ; MEMORY LINE JMP MLOOP;JMPDON JMP DONE;;*******************************;*                             *;* THE SEMICOLON  COMMAND WILL *;* ENTER   A   NEW   PROCESSER *;* ADDRESS, A PROCESSER STATUS *;* NEW  REGISTERS  AND  A  NEW *;*        STACK POINTER.       *;*                             *;* SYNTAX:                     *;*                             *;* .;C000 10110010 41 01 FF F4 *;*                             *;*******************************;SEMI JSR GETTWO ; GET PROCESSER ADDRESS BCC JMPDON ; NOTHING THERE, EXIT; JSR SETPC ; SET PCLO AND PCHI POINTERS LDA #1 ; ASSUME BINARY MODE STA NMODE JSR GETHEX ; GET STATUS REGISTER IN BINARY BCC NOMRG STA PROCES AND #0 ; ASSUME HEX AGAIN STA NMODE LDA #<AREG ; SET POINTER TO REGISTERS LDY #>AREG STA POINT1 STY POINT1+1 LDA #4 STA LINE ; SET COUNTER FOR DIGITSNCOLON JSR PUTBYT ; GET AND STORE REGISTER BCC NOMRG ; NO MORE REGISTERS BNE NCOLON ; COUNT FOR  ALL REGISTERS;NOMRG JSR CLEART ; GO TO BEGINING OF LINE JSR DOREG ; AND REPRINT LINE JMP REREG;;*************************;*                       *;* THIS COMMAND (:) WILL *;* ALLOW  YOU  TO  ENTER *;* ANY NUMBER  OF  BYTES *;* INTO   MEMORY,  AFTER *;* IT ENTERS THE DATA IT *;* WILL REPRINT THE LINE *;*                       *;* SYNTAX:               *;*                       *;* .:0800 00 FF FF 0A... *;* .:0800 "ÈELLO ÔHERE.. *;*                       *;*************************; .IFE EXTRAS <COLON AND #0 ; SET OMODE STA OMODE JSR GETTWO ; GET ADDRESS> .IFN EXTRAS <COLON JSR GETTWO ; GET ADDRESS> BCC JMPDON JSR PNT1T2 ; COPY POINT1 TO POINT2 LDA #74 ; ENTER 74 DIGITS; STA LINEBYTLOP JSR PUTBYT ; PUT BYTE INTO MEMORY BCC RELIST BNE BYTLOP;RELIST JSR CLEART ; START A BEGINING OF LINE JSR FLIPTS ; RETURN LOCATION JSR MLINE JMP DONE; .IFE EXTRAS <MLINE LDA SIGN> .IFN EXTRAS <MLINE LDA #"."> JSR PRINT JSR PRTCOL ; REPRINT A COLONML2 JSR PRTTWO ; PRINT LOCATION JSR MEMLIN ; NOW MAP THIS LINE JMP PRTCOL ; PRINT A COLON AFTER LINE;;*****************************;*                           *;* THIS IS THE "GO" FUNCTION *;* THIS WILL EXECUTE CODE AT *;* A  GIVEN  ADDRESS,  IF NO *;* ADDRESS  IS   GIVEN,  THE *;* CODE WILL BE  EXECUTED AT *;* THE   LOCATION   IN   THE *;*        PROCESSER          *;*                           *;* SYNTAX:.G 0800            *;*  ...OR:.G                 *;*                           *;*****************************;GO JSR GETTWO ; GET ADDRESS BCC GETOUT ; IF END-OF-LINE, JUMP TO PC JSR SETPC ; SET REGISTERS PC .IFE EXTRAS <GETOUT LDA DCMODE ; CHECK FOR COMPUPUTER OR DRIVE BEQ YAKYAK LDA MEMDEV ; TELL DEVICE TO LISTEN FOR M-E JSR LISTEN LDA #$F0+15 ;...LISTEN TO CHANNEL 15 JSR SALIST LDA #"M" JSR OBYTE LDA #"-" JSR OBYTE LDA #"E" JSR OBYTE LDA PCLO ; SEND ADDRESS JSR OBYTE LDA PCHI JSR OBYTE JSR UNLIST ; UNLISTEN DEVICE AND #0 ; GO OUT OF DISK MODE STA DCMODE LDA #"." ; SET BACK TO NORMAL "." STA SIGN JMP DONE;YAKYAK JSR OUT ; LOAD UP EVERYTHING AND JUMP> .IFN EXTRAS <GETOUT JSR OUT ; LOAD UP EVERYTHING AND JUMP> LDX STACK INX INX ; MAKE ROOM FOR RETURN ADDRESS TXS ; SET STACK POINTER LDA #>ALLANY ; PUSH RETURN ADDRESS PHA LDA #<ALLANY-1 PHA LDA PCHI PHA ; PUSH ON STACK VECTOR LDA PCLO PHA LDA PROCES STA SP PHA LDA AREG ; LOAD ALL REGISTERS STA AC LDX XREG STX XR LDY YREG STY YR RTI ; RTI=PLP AND RTS-1;ALLANY TSX ; SET CORRECT STACK VALUE DEX DEX TXS JMP ALLANX ; NOW DO "BREAK";;**********************;*                    *;* EXIT BACK TO BASIC *;* THE  CURRENT   ROM *;* STATE IS  RESET TO *;* FLIP  THE ROMS IN, *;* ANY STACK PROBLEMS *;*    ARE CORRECTED   *;*                    *;* SYNTAX:.X          *;*                    *;**********************;EXIT LDX #248 ; RESET STACK TXS LDA PROCES ; SET STATUS FOR BASIC STA SP LDA AREG ; LOAD REGISTERS FOR BASIC LDX XREG LDY YREG STA AC ;...AND SAVE 'EM FOR NEXT CALL STX XR STY YR JMP (BASVEC) ; RETURN TO BASIC;;******************************;*                            *;* THE E COMMAND WILL DISPLAY *;* A LINE OF MEMORY IN QUOTES *;* IT WILL  DISPLAY  24 BYTES *;* AT A TIME,  YOU  CAN  EDIT *;* THESE TO ANYTHING YOU WANT *;*                            *;* SYNTAX:.E 0400 0500        *;*                            *;******************************; ELENGH=32 ; LENGTH OF ELINE STRING; .IFE EXTRAS <ECOM LDA #1 ; SET OMODE STA OMODE JSR GTRANG ; GET ADDRESS RANGES> .IFN EXTRAS <ECOM JSR GTRANG ; GET ADDRESS RANGES>;ELOOP JSR CHKEND ; COMPARE LOCATIONS BCC DONE9 ; CARRY CLEAR IF DONE JSR PRTRET JSR ELINE ; NOW PRINT LINE BCS DONE9 ; CHECK IF YOUR OVER $FFFF JSR PAUSE ; CHECK STOP KEY OR PAUSE JMP ELOOP;DONE9 JMP DONE;ELINE AND #0 ; PRINT LINE OF "E" COMMAND STA RVSFLG ; CLEAR REVERSE MODE STA TEMP2 .IFE EXTRAS < LDX SIGN ; PRINT CURRENT SIGN> .IFN EXTRAS < LDX #"."> LDA #">" ; PRINT DOT AND WEDGE JSR TWOCHR JSR PRTTWO ; PRINT LOCATION JSR PRTSPC ;...THEN A SPACE JSR OUT ; FLIP ROMS OUT LDY #6+1 STY TAB ; SAVE SCREEN TAB LDA #ELENGH-1 ; SET MEMORY INDEXER STA TEMP1;PRTINE JSR OUT LDY TEMP2 .IFE EXTRAS < JSR GETPT1 ; GET BYTE FROM LOCATION> .IFN EXTRAS < LDA (POINT1),Y ; GET BYTE FROM LOCATION> LDY TAB STA (PNT),Y ; STORE ON SCREEN JSR IN ; FLIP COLOUR RAM IN LDA COLOUR ; PUT COLOUR SO YOU CAN SEE IT STA (COLPNT),Y INC TEMP2 INC TAB DEC TEMP1 BPL PRTINE ; COUNT FOR ALL LOCATIONS; LDA POINT1 ; NOW ADD TO POINTER CLC ADC #ELENGH STA POINT1 LDA POINT1+1 ; ADD CARRY TO HIGH BYTE ADC #0 STA POINT1+1 RTS;;*****************************;*                           *;* THE WEDGE IS LIKE THE (:) *;* BUT WILL  ENTER TEXT THAT *;* THE E COMMAND PRINTS,  32 *;* BYTES WILL BE  ENTERED AT *;* A TIME,  NO  MORE  AND NO *;*          LESS             *;*                           *;* SYNTAX:                   *;*                           *;* .>0400 HELLO THERE...     *;*                           *;*****************************; .IFE EXTRAS <WEDGE LDA #1 ; SET OMODE STA OMODE JSR GETTWO ; GET ADDRESS> .IFN EXTRAS <WEDGE JSR GETTWO ; GET ADDRESS> BCC DONE9 JSR PNT1T2 ; SAVE POINTER LDA #ELENGH+6 ; SET LAST POSITION TO SCAN BACK STA TEMP1 ; AND SAVE AS SCREEN INDEXER LDA #ELENGH-1 ; 32 LOCATIONS TO INPUT STA TEMP2 JSR OUT ; FLIP ROMS OUT BEFORE LOOP;WDLOOP LDY TEMP1 ; GET SCREEN INDEXER LDA (PNT),Y ; GET VALUE FROM SCREEN LDY TEMP2 ; RESET INDEXER FOR MEMORY .IFE EXTRAS < JSR PUTPT1 ; PUT BYTE IN MEMORY> .IFN EXTRAS < STA (POINT1),Y ;...THEN STORE BYTE IN MEMORY> DEC TEMP1 ; DECREASE SCREEN POINTER DEC TEMP2 ; DECREASE MEMORY POINTER BPL WDLOOP ; CHECK IF IM DONE; JSR IN ; NOW FLIP ROMS BACK IN JSR CLEART ; GO TO BEGINING OF LINE JSR FLIPTS ; RESTORE LOCATION JSR ELINE ; THEN PRINT THE NEW LINE JMP DONE ;...THEN EXIT;OUT SEI ; FLIP ROMS OUT PHP ; PUSH STUFF PHA LDA R6510 ; STORE ROM STATE STA ROMS PLA ; RESTORE STUFF PLP RTS;IN PHP ; FLIP ROMS IN PHA LDA ROMS ; SAVE ROM STATE STA R6510 LDA #%00110111 ; NORMAL ROM STATE STA ROMS PLA PLP CLI ; ROMS IN, IRQ'S ARE NOW ALLOWED RTS;CHARS PHA ; PUT CHARACTERS AT END OF LINE JSR OUT LDA #40 ; START FROM END OF SCREEN CLC SBC LINE ; SUBTRACT INDEXED LINE TAY PLA STA (PNT),Y ; STORE ON LINE LDA COLOUR JSR IN ; FLIP COLOUR RAM IN STA (COLPNT),Y RTS;REBRK LDA #<BRKVEC ; RESET BREAK VECTOR LDY #>BRKVEC ; (AFTER RUN/STOP AND RESTORE) STA BREAK STY BREAK+1JWARM JMP $A483 ; WILL BE MODIFIED; .IFE EXTRAS <GTHEX JSR SETNYB ; SET FIRST NYBBLE ASL A ; SHIFT TO CORRECT POSITION ASL A ASL A ASL A STA TEMP1 ; SAVE IT... JSR SETNYB ; TURN INTO NYBBLE ORA TEMP1 ; MIX IN HIGH NYBBLE RTS;SETNYB JSR GET CMP #"A" ; TURN ASCII INTO NYBBLE BCC NG ; NOT GREATER THAN 10, SKIP SBC SBC #7 ; TURN "A"+ INTO ":"+NG AND #$F ; KILL OFF ASCII RTS;;********************************;*                              *;* THIS IS THE COMMODORE OBJECT *;* FILE  LOADER.   THIS  LOADER *;* HAS THE SAME SYNTAX  AS  THE *;* NORMAL LOAD BUT  RATHER THAN *;* A  NEW  LOAD  ADDRESS,  THIS *;*   USES THE OFFSET PRINCIPAL  *;*                              *;* SYNTAX:.* "NAME"             *;*  ...OR:.* 9,"NAME"           *;*   ..OR:.* "NAME",2000        *;*                              *;********************************;LOADO AND #0 ; CLEAR ANY OFFSET STA TEMP9 STA TEMP9+1 JSR GETNAM ; GET FILENAME AND DEVICE BCC NOFFSX ; NO OFFSET... JSR DIGER2 LDA POINT1 ; TRANSFER OFFSET TO TEMP9 LDY POINT1+1 STA TEMP9 STY TEMP9+1NOFFSX LDX NUMCHR ; ADD ",S" TO FILENAME LDA #"," STA NAME,X LDA #"S" STA NAME+1,X INC NUMCHR ; INC TO COMPENSATE FOR ",S" INC NUMCHR AND #0 ; CLEAR RANGE AND SHIT STA TEMP5 STA TEMP5+1 STA TEMP2 STA TEMP2+1 STA ST STA TEMP4; JSR OPENIT LDX #DSKFIL JSR CHKIN;ILSH3 JSR GETIT ; FIND RANGE START CMP #";" BNE ILSH3;ASDASD AND #0 ; CLEAR CHECKSUM STA TEMP7 STA TEMP7+1 JSR GTHEX ; GET NUMBER OF BYTES ON LINE STA LINE BNE NCHKRN JMP CHKRNG;NCHKRN JSR ADDSUM INC TEMP5 ; COUNT RANGES BNE NHIGHR INC TEMP5+1NHIGHR JSR GTHEX ; GET HIGH BYTE OF LOCATION PHA ; SAVE BYTE STA POINT2+1 JSR ADDSUM ; ADD TO CHECKSUM PLA ; RETURN BYTE CLC ADC TEMP9+1 ; ADD OFFSET STA POINT1+1 JSR GTHEX ; GET LOW BYTE PHA STA POINT2 JSR ADDSUM PLA CLC ADC TEMP9 ; ADD OFFSET STA POINT1 BCC NODHA INC POINT1+1NODHA LDA #1 ; SET LOCV FLAG STA TEMP4 LDA TEMP5 ; CHECK IF FIRST RANGE SEC SBC #1 ORA TEMP5+1 BEQ ITS1ST LDA TEMP2+1 LDY TEMP2 CMP POINT1+1 ; CHECK NEED TO PRINT LOCATION BNE ITS1ST CPY POINT1 BEQ OKLITS1ST LDA #13 ; PRINT RETURN FOR NEW LINE JSR PRINT LDA POINT1+1 ; SET NEW ADDRESS LDY POINT1 STA TEMP2+1 STY TEMP2 JSR PRTEM ; PRINT LOCATION JSR STROUT .BYTE "-    ",0 LDA TEMP9 ; CHECK TO PRINT OFFSET LOCATION ORA TEMP9+1 BEQ OKL LDA #"," ; PRINT ", " AFTER LOCATIONS JSR PRINT LDA #" " JSR PRINT JSR PRTTWO ; PRINT CORRESPONDING LOCATION JSR STROUT ; PRINT DASH AND BACKSPACES .BYTE "-",157,157,157,157,157,157,157,0;OKL LDY #0 ; CLEAR INDEXERPUTM JSR GTHEX ; START PUTTING BYTES IN MEMORY JSR OUT ; FLIP ROMS OUT STA (POINT1),Y ; PUT BYTE IN MEMORY JSR ADDSUM ; ADD TO CHECKSUM JSR IN ; FLIP ROMS IN TYA CLC ; CALCULATE LAST VALUE ADC POINT1 STA TEMP2 LDA POINT1+1 STA TEMP2+1 BCC SKDA INC TEMP2+1SKDA CPY #0 ; BUMP POINT2 VALUE BEQ SKDA2 INC POINT2 BNE SKDA2 INC POINT2+1SKDA2 INY ; INC BYTE INDEXER DEC LINE ; DEC COUNTER BNE PUTM; JSR GTHEX ; CHECK CHECKSUM CMP TEMP7+1 BNE ERROR1 ; ERROR... JSR GTHEX CMP TEMP7 BNE ERROR1 ; ERROR... JSR PRTLOC ; REPRINT NEW ADDRESS INC TEMP2 ; INC TO MAKE FINAL CALCULATION BNE GILSHX INC TEMP2+1GILSHX JMP ILSH3;ERROR1 JSR CLOSEF JSR STROUT .BYTE 13,"CHECKSUM ERROR",0 JMP PRTST ; PRINT DISK STATUS;ADDSUM CLC ; ADD .A TO CHECKSUM ADC TEMP7 STA TEMP7 BCC DONADD ; TAKE CARE OF HIGH BYTE INC TEMP7+1DONADD RTS;GETIT JSR GET LDX ST ; CHECK STATUS BYTE BNE ANTA2; PHA ; SAVE GOTTON CHARACTER JSR STOP BNE LOASFDANTA2 JSR PRTLOCANTA JSR CLOSEF ; CLOSE FILES JMP PRTST;LOASFD PLA RTS;CHKRNG JSR GTHEX ; GET RANGES CMP TEMP5+1 BNE ERROR9 JSR GTHEX ; CHECK LOW BYTE CMP TEMP5 BEQ ANTAERROR9 JSR CLOSEF ; CLOSE FILE JSR STROUT ; OUTPUT ERROR STRING .BYTE 13,"RANGE ERROR",0 JMP PRTST;PRTEM JSR FLIPTS ; PRINT NORMAL LOCATION... JSR PRTTWO ; PRINT HIGH LOCATION JMP FLIPTS ;...NOW LOW BYTE;PRTLOC LDA TEMP4 ; CHECK IF BYTES GOTTON BEQ NOFFST ; NOT YET... JSR STROUT .BYTE 157,157,157,157,0 JSR PRTEM ; PRINT LOCATION LDA TEMP9 ; TEST TO PRINT OFFSET LOCATION ORA TEMP9+1 BEQ NOFFST ; NO OFFSET... JSR STROUT ; PRINT CORRESPONDING LOCATION .BYTE 29,29,29,29,29,29,29,0 JSR PNTTMP ; FLIP TEMP2 WITH POINT1 JSR PRTTWO ; PRINT POINT1, LOCATION THAT IS JSR PNTTMP ; RETURN TEMP2 AND POINT1 JSR STROUT ; GO BACK AGAIN .BYTE 157,157,157,157,157,157 .BYTE 157,157,157,157,157,0NOFFST RTS;> .FILE STRINGMON.2