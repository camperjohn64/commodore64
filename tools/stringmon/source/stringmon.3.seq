 .PAGE "STRINGMON.3";******************************;*                            *;* THIS COMMAND WILL TRANSFER *;* MEMORY  FROM  ONE  AREA TO *;* ANOTHER,   OVERLAPPING  IS *;* ALLOWED  BECAUSE  IT  WILL *;* TRANSFER  THE  DATA  BLOCK *;*    FORWARD OR BACKWARD     *;*                            *;* SYNTAX:.T 0800 0900 0400   *;*                            *;******************************;TRANS JSR GETTWO ; GET FIRST ADDRESS BCC IMDONE ; EXIT IF NONE JSR FLIPTS ; SAVE IT TO (POINT2) JSR DIGERR ; GET SECOND RANGE JSR PNTTMP ; TRANSFER POINT1 TO TEMP2 JSR DIGERR ; GET LAST VALUE JSR CHKEND ; FIRST GREATER THAN LAST? JSR FLIPTS JSR OUT BCC TBACK ; YES, BACKWARD TRANFERTLOOP LDX TEMP4 ; NO, FORWARD TRANSFER BNE IMDONE ; DID WE GO OVER FFFF? JSR CHKTMP ; FINESHED YET? BCC IMDONE .IFE EXTRAS < LDY #0 JSR GETPT1 ; GET FROM POINT1 JSR PUTPT2 ; PUT IN POINT2> .IFN EXTRAS < LDA (POINT1,X) ; TRANSFER THE BYTES STA (POINT2,X)> JSR INCPT2 ; INCREMENT BOTH POINTERS JSR INCPT1 BNE TLOOP ; ALWAYS BRANCH;TBACK JSR CHKTMP ; BACKWARD TRANSFER CLC LDA TEMP6 ; FIND END OF TRANSFER POINT ADC POINT2 STA POINT2 TYA ADC POINT2+1 STA POINT2+1 JSR PNTTMP ; TRANSFER POINT1 TO TEMP2BLOOP LDX TEMP4 ; DID WE GO UNDER 0000? BNE IMDONE .IFE EXTRAS < LDY #0 JSR GETPT1 ; TRANSFER LOCATIONS JSR PUTPT2> .IFN EXTRAS < LDA (POINT1,X); TRANSFER LOCATIONS STA (POINT2,X)> JSR CHKTMP ; ARE WE DONE YET BCS IMDONE JSR DECPT1 ; DECREMENT BOTH POINTERS JSR DECPT2 JMP BLOOP;IMDONE JSR IN JMP DONE;;********************************;*                              *;* THIS COMMAND IS USED TO FILL *;* AN AREA  OF  MEMORY WITH THE *;* SAME VALUE  OR SAME  PATTERN *;* OF VALUES, TEXT OR HEX DIGIT *;*    INPUT WILL BE ACCEPTED    *;*                              *;* SYNTAX:.F 0800 0900 00       *;*  ...OR:.F 0800 0900 "ABC"    *;*   ..OR:.F 0800 0900 "AB",43  *;*                              *;********************************;FILL JSR GETTWO BCC IMDONE JSR FLIPTS ; FLIP POINTERS JSR DIGERR ; GET NEXT ADDRESS JSR FLIPTS ; FLIP POINTERS BACK JSR STRING ; GET FILLING STRING LDX #0 STX LAST JSR OUTFILOOP LDX TEMP4 ; OVER FFFF? BNE MAYDON JSR CHKEND ; LAST LOCATION FILLED? BCC MAYDON LDX LAST LDA TABLE,X ; IF NOT, FILL WITH TABLE,LAST INX ; INCREASE X FOR NEXT VALUE CPX TEMP5 ; FINISHED TABLE OF VALUES? BNE SSTORE; LDX #0 ; YES, RESET INDEXERSSTORE STX LAST LDY #0 .IFE EXTRAS < JSR PUTPT1> .IFN EXTRAS < STA (POINT1),Y> JSR INCPT1 ; INCREMENT POINTER BNE FILOOP ; AND DO MORE, ALWAYS BRANCH;MAYDON JSR INOKDONE JMP DONE;;*************************;*                       *;* YOU   WILL   NOW   BE *;* TORTURED  BY  READING *;* HOW TO  USE  THE HUNT *;* COMMAND. THIS COMMAND *;* SEARCHES FOR A STRING *;* THAT CAN BE IN HEX OR *;* ASCII  DIGITS,   WHEN *;* IT FINDS IT,  IT WILL *;* PRINT OUT THE ADDRESS *;*     OF WHERE IT IS    *;*                       *;* SYNTAX:               *;*                       *;* .H 0800 0900 41 42 43 *;* .H 0800 0900 "ABC"    *;* .H 0800 0900 "ABC",44 *;*                       *;*************************;HUNT JSR GETTWO ; GET STARTING ADDRESS BCC OKDONE JSR FLIPTS ; SAVE IT JSR DIGERR ; GET NEXT ADDRESS JSR FLIPTS ; RESTORE POINTERS JSR STRING ; SETUP "TABLE" JSR PRTRET .IFE EXTRAS < LDA #16 ; SET UP LINE LENGTH STA LINE>RELOOP LDX #0 ; RESTART CHECKING FROM LDY #0 ; BEGINING OF TABLECTLOOP JSR OUT .IFE EXTRAS < JSR GETPT1> .IFN EXTRAS < LDA (POINT1),Y ; CONTINUE CHECKING> JSR IN CMP TABLE,X ; CHECK IF FOUND BNE NOTEQ INY ; VALUE ALMOST FOUND INX ;...MUST CHECK ALL OF TABLE CPX TEMP5 BNE CTLOOP; JSR PRTTWO ; PRINT LOCATION .IFE EXTRAS < DEC LINE ; COUNT FOR RETURN BNE NOTEX LDA #13 ; PRINT RETURN JSR PRINT LDA #16 ; RESET LINE COUNTER STA LINE BNE NOTEQ>;NOTEX JSR PRTSPC;NOTEQ JSR INCPT1 ; INCREASE POINTER JSR PAUSE ; CHECK STOP KEY OR PAUSE LDX TEMP4 ; OVER FFFF? BNE OKDONE JSR CHKEND ; DONE YET? BCS RELOOP; JMP DONE;STRING LDX #0 ; SET UP "TABLE" STX TEMP5;STLOOP JSR GETHEX ; GET DIGIT BCC STEND LDX TEMP5 STA TABLE,X ; STORE IN TABLE INC TEMP5 ; AND GO FOR NEXT NUMBER LDA TEMP5 ; CHECK FOR TABLE OVERFLOW CMP #NUMCHR-TABLE BNE STLOOP ; ALWAYS;STEND RTS ; YOU CAN GO FOR A SODA NOW... .IFE EXTRAS <;;*********************;*                   *;* NEW INPUT ROUTINE *;*                   *;*********************;INPUT LDA TAB ; SAVE BEGINGING TAB STA LXSP+1 LDA TBLX STA LXSP TYA PHA TXA PHA LDA IO ; CHECK FOR KEYBOURD INPUT BNE TOLOP5 ; NO, EXIT; STA QUOTE ; KILL QUOTE FOR SCROLLING LDA #25 ; SET PRINT LINE TO MAXIMUM+1 STA TEMPA;BASIN3 JSR DOPRTBASIN4 LDA KEYLEN ; GET KEYBOURD BUFFER LENGTH STA BLNSW ; SAVE NUMBER OF CHARACTERS STA AUTODN ; IN HERE BEQ BASIN4 ; WAS IT ZERO?; SEI ; NO, HE PRESSED SOMETHING LDA BLNON ; GET CURSOR ON/OFF POSITION BEQ BASIN5 LDA GDBLN ; CURSOR WAS ON LDX GDCOL LDY #0 ; SO SWITCH IT OFF STY BLNON JSR DSPPBASIN5 JSR LP2 ; INPUT CHARACTER CMP #13 ; WAS IT A RETURN? BNE BASIN3 ; NO, PRINT CHARACTER; LDA #%11111111 STA QUOTE ; SET QUOTE MODE JSR BASIN8 ; SET UP SCREEN STUFF LDY #0 STY AUTODN STY CALNUM+1 STY TAB STY QTSW LDA LXSP ; GET X POSITION OF INPUT BMI TOLOP5 LDX TBLX JSR FINDST CPX LXSP BNE TOLOP5 LDA LXSP+1 CMP INDX BCC TOLOP5 JMP CLP2;BASIN8 LDA #13 ; SET UP SCREEN SHIT STA OLDFLG ; SET OLDFLG FLAG LDY MAXLIN ; GET MAXIMUM LINE LENGTH (40) STY IOBASIN6 LDA (PNT),Y ; GET CHARECTER CMP #" " ; COMPARE IT WITH A SPACE BNE BASIN7 ; NOT A SPACE, END OF LINE FOUND DEY ; GO FOR NEXT CHARACTER TO LEFT BNE BASIN6;BASIN7 INY ; END OF LINE FOUND STY INDX ; SAVE IT HERE RTS;TOLOP5 JMP LOP5;;*********************;*                   *;* NEW PRINT ROUTINE *;*                   *;*********************;DOPRT PHA ; SAVE A STA TDAT3 TXA ; AND SHOVE X AND Y ON STACK PHA TYA PHA LDA TDAT3 ; RE-LOAD CHARACTER LDX #DOCHRL-CHRS-1NCKCHR CMP CHRS,X ; CHARACTER A SPECIAL KEY? BEQ DOCHR ; YEP, DO THAT CHARECTER DEX ; NO, CHECK OTHER CHARACTERS BPL NCKCHR;DOPRT2 LDA TDAT3 STA CRSFLG JMP PRINT2 ; FINALY PRINT THE CHARACTER;DOCHR AND #0 ; CLEAR CALNUM+1 FOR CURSOR KEYS STA CALNUM+1 CPX #2 ; CHECK FOR CURSOR KEY BCC YCUR LDA #1 ; NOT CURSOR KEY, SET FLAG STA CRSFLGYCUR JSR DOCHR2 ; DO SPECIAL KEY AND #0 STA QUOTE ; KILL QUOTE MODE FOR GETHEX PLA ; RE-LOAD JUNK AND RETURN TAY PLA TAX PLA RTS;DOCHR2 LDA DOCHRH,X ; GET HIGH BYTE OF VECTOR PHA ; SHOVE IT ON THE STACK LDA DOCHRL,X ; NOW GET THE HIGH BYTE PHA ; SHOVE IT ON THE STACK TOO PHP ; PHP FOR RTI NOT RTS RTI ; RTI=PLP, RTS-1;CHRS .BYTE CRSRDN ; CURSOR DOWN .BYTE CRSRUP ; CURSOR UP .BYTE SHRUN ; NEW SHIFT/RUN FOR DISK .BYTE DELKEY ; BLACK HOLE DELETE .BYTE 4 ; CONTROL D .BYTE 16 ; CONTROL P .BYTE F1 ; GO TO TAB .BYTE F2 ; SET/CLEAR TAB .BYTE F3 ; DELETE BEFORE CURSOR .BYTE F4 ; DELETE AFTER CURSOR .BYTE F5 ; CLEAR RANGE AFTER CURSOR .BYTE F6 ; CLEAR RANGE BEFORE CURSOR .BYTE F7 ; UPSIDEDOWN CURSOR HOME .BYTE F8 ; ESCAPE KEY;DOCHRL .BYTE <DOCDN ; VECTORS FOR NEW KEYS .BYTE <DOCUP .BYTE <DOSRUN .BYTE <DODEL .BYTE <CTRLD .BYTE <CTRLP .BYTE <DOF1 .BYTE <DOF2 .BYTE <DOF3 .BYTE <DOF4 .BYTE <DOF5 .BYTE <DOF6 .BYTE <DOF7 .BYTE <DOF8;DOCHRH .BYTE >DOCDN .BYTE >DOCUP .BYTE >DOSRUN .BYTE >DODEL .BYTE >CTRLD .BYTE >CTRLP .BYTE >DOF1 .BYTE >DOF2 .BYTE >DOF3 .BYTE >DOF4 .BYTE >DOF5 .BYTE >DOF6 .BYTE >DOF7 .BYTE >DOF8;;********************;*                  *;* SCROLL SCREEN UP *;*                  *;********************;SCRLUP LDA LDTB1+1 ; SET SINGLE LINE ORA #%10000000 STA LDTB1+1 JSR SCROL ; SCROLL SCREEN JMP STUPT ; RECALCULATE CURSOR POSITION;;**********************;*                    *;* SCROLL SCREEN DOWN *;*                    *;**********************;SCRLDN LDX #0 ; SCROLL SCREEN FROM YPOS 0 JSR BMTLA LDA LDTB1 ; SET SINGLE LINE ORA #%10000000 STA LDTB1 JMP STUPT ; RECALCULATE CURSOR POSITION;;******************;*                *;* DO CURSOR DOWN *;*                *;******************;DOCDN LDA TBLX ; GET CURSOR Y POSITION CMP #24 ; IS IT ON THE LAST LINE? BEQ DOCDN3DOCDN2 PLA ; NO, DO A NORMAL PRINT PLA JMP DOPRT2;DOCDN3 LDA QTSW ; YES, CHECK FOR QUOTE OR ORA INSRT ;...INSERT MODES ON BNE DOCDN2 STA RVSFLG ; ITS OK, CLEAR REVERSE FLAG CMP CRSFLG BEQ DNAG STA CRSFLG JSR SET2FF ; SET POINT2 TO $FFFF... JSR FLIPTS JSR SETSCR LDA #24 STA TEMP5FLADN JSR SCANL ; FIND LOCATION BCS FFD2DN ; LOCATION FOUND, EXIT LDA SCREEN SEC SBC #40 ; SBC FOR NEXT LINE STA SCREEN BCS NH5 ; NO HIGH BYTE DEC... DEC SCREEN+1 ; DEC HIGH BYTE OF POINTERNH5 DEC TEMP5 BPL FLADN; AND #0 ; CLEAR POINTER IF SCREEN BLANK STA POINT1 STA POINT1+1 JSR SCRLUP ; SCROLL SCREEN UP NOW JMP PRTLIN ; PRINT LINE, DON'T ADD LENGTH;DNAG LDX OMODE ; DO CURSOR DOWN AGAIN LDA LENGHS,X ; SET UP LENGTH AGAIN STA LENGTH;FFD2DN JSR SCRLUP ; SCROLL SCREEN UP LDY LENGTH ; CHECK FOR DISASSEMBLEY BNE ADDL JSR OUT ; FLIP ROMS OUT TO GET BYTE JSR GETPT1 ; Y=0 JSR IN JSR FNDLGN ; FIND DISASSEMBLEY LENGTH INC LENGTHADDL DEC LENGTH ; DEC LENGTH FOR "ADDLEN" JSR ADDLEN ; ADD "LENGTH" TO "POINT1" STA POINT1 STY POINT1+1 JMP PRTLIN ; PRINT LINE;;****************;*              *;* DO CURSOR UP *;*              *;****************;DOCUP LDA TBLX ; GET CURSOR Y BEQ DOCUP3 ; ZERO, SCROLL UPDOCUP2 JMP DOCDN2;DOCUP3 LDA QTSW ; CURSOR UP, CHECK QUOTE MODE ORA INSRT ;...AND INSERT MODE BNE DOCUP2 STA RVSFLG ; NONE, KILL REVERSE MODE CMP CRSFLG ; CHECK FOR CURSOR FLAG BEQ UPAG ; YES... STA CRSFLG ; SET CURSOR FLAG JSR SET2FF ; SET POINT2 TO $FFFF... JSR FLIPTS JSR SETSCR LDA #24 STA TEMP5FLA JSR SCANL ; FIND LOCATION BCS FFD2LC ; LOCATION FOUND, EXIT LDA SCREEN CLC ADC #40 ; ADD FOR NEXT LINE STA SCREEN BCC NH4 ; NO HIGH BYTE INC... INC SCREEN+1 ; INC HIGH BYTE OF POINTERNH4 DEC TEMP5 BPL FLA; AND #0 ; CLEAR POINTER IF SCREEN BLANK STA POINT1 STA POINT1+1UPAG LDX OMODE ; SET UP UNKNOWN LENGTH LDA LENGHS,X STA LENGTH;FFD2LC JSR SCRLDN ; SCROLL SCREEN DOWN LDA LENGTH ; CHECK FOR DISASSEMBLEY BNE SUBL; UPDLEN=30 ; DISASSEMBLE UP STRETCH; LDA POINT1 ; SUBTRACT FROM POINT1 SEC SBC #UPDLEN STA POINT1 ; SAVE LOW BYTE BCS NDOA DEC POINT1+1 ; DEC HIGH BYTE IF NECESSARYNDOA LDA #UPDLEN-1 ; SET LENGTH TO POINT1 STA TABLE+12FDL LDY #0 ; SET UP VARIABLE LENGTH JSR OUT ; FLIP ROMS OUT TO GET BYTE JSR GETPT1 ; GET VALUE FOR DISASSEMBLEY JSR IN ; FLIP ROMS BACK IN JSR FNDLGN ; FIND LENGTH LDX LENGTH CPX TABLE+12 BCS PRTLIN JSR ADDLEN ; NOW ADD LENGTH STA POINT1 ; SAVE NEW POINTER STY POINT1+1 LDA TABLE+12 ; SUBTRACT LENGTH FROM COUNTER CLC SBC LENGTH STA TABLE+12 BPL FDL ; ALWAYS...;SUBL LDA POINT1 ; SUBTRACT LENGTH FROM POINT1 SEC SBC LENGTH ; LENGTH SET UP BY SCANL ROUTINE STA POINT1 BCS PRTLIN ; TEST HIGH BYTE DEC DEC POINT1+1;PRTLIN LDA TAB ; PRINT LINE FROM POINT1 & OMODE PHA ; SAVE TAB LOCATION LDA POINT1 ; SAVE PRINT LOCATION PHA LDA POINT1+1 PHA AND #0 ; CLEAR TAB STA TAB JSR DOJMP ; PRINT TYPE PLA ; RETURN PRINT LOCATION STA POINT1+1 PLA STA POINT1 PLA ; RESTORE TAB STA TAB RTS;DOJMP LDX OMODE ; GET OUTPUT MODE LDA HIGHM,X ; PUSH MODE ADDRESSES ON STACK PHA LDA LOWM,X PHA RTS;HIGHM .BYTE >MLINE ; VECTORS TO LINE PRINTING .BYTE >ELINE .BYTE >DIS4;LOWM .BYTE <MLINE-1 .BYTE <ELINE-1 .BYTE <DIS4-1;SETSCR LDA PNT ; SET UP "SCREEN" LDY PNT+1 STA SCREEN STY SCREEN+1 RTS;SCANL LDY #255 ; SET STARTING TAB LDA SIGN ; SET SIGN AND #%00111111 STA TEMP1SCLOOP INY ; INC FOR NEXT CHARACTER CPY #40 ; #40, NOT MAXLIN BEQ NTO ; OFF SCREEN... LDA (SCREEN),Y ; GET CHARACTER CMP #" " ; IGNORE SPACES... BEQ SCLOOP CMP TEMP1 ; IGNORE STARTING "." OR "]" BEQ SCLOOP LDX #0 ; SET ASSUMED INDEXER CMP #":" ; CHECK FOR MEMORY BEQ FONDX INX ; INC ASSUMED INDEXER CMP #">" ; CHECK FOR E COMMAND BEQ FONDX INX ; INC ASSUMED INDEXER CMP #"," ; CHECK FOR DISASSEMBLEY BEQ FONDXNTO CLC ; NO COMMAND ON THIS LINE... RTS;OTOVIT JSR SCRPNT ; MISSING DATA CHARACTER, EXIT CLC RTS;FONDX LDA LENGHS,X ; SET COMMAND LENGTH STA LENGTH STX OMODE ; SET OUTPUT MODE INY ; INC PAST OUTPUT TYPE, ":>," STY TAB2 ; SAVE NEW TAB JSR SCRPNT ; FLIP SCREEN WITH PNT AND TAB INC IO ; INPUT FROM SCREEN JSR BASIN8 JSR GETTWO ; GET HEX VALUE BCC OTOVIT ; NO DIGIT, CLC FOR ERRORSCRPNT LDA SCREEN ; SWITCH LOW BYTES OF POINTER LDX PNT STA PNT STX SCREEN LDA SCREEN+1 ; NOW SWITCH HIGH BYTES LDX PNT+1 STA PNT+1 STX SCREEN+1 LDA TAB ; SWITCH TAB POSITIONS LDX TAB2 STA TAB2 STX TAB SEC ; SEC FOR GOOD INPUT RTS;LENGHS .BYTE 8,ELENGH,0;;*********************;*                   *;* DO SHIFT RUN/STOP *;*                   *;*********************;DOSRUN LDX #0NDOSR1 LDA SRSTR1,X ; GET LOAD":* FROM TABLE JSR PRINT ; AND PRINT IT INX CPX #SRSTR2-SRSTR1 ;...AM I DONE PRINTING? BCC NDOSR1; SEI ; STOP IRQ'S FIRST LDA #13 LDX KEYLEN ; GET TABLE LENGTH STA KEYBUF,X ; PUT IN BUFFER INC KEYLEN; CLI ; ALLOW IRQ'S NOW RTS ; AND GO FOR IT!;SRSTR1 .BYTE "L",34,":*"SRSTR2;;********************;*                  *;* BLACKHOLE DELETE *;*                  *;********************;DODEL LDY DELFLG ; CHECK DELETE TYPE BEQ SASDAV ; SATISFIED DAVID? LDY TAB ; GET CURSOR TABCHKDEL LDA (PNT),Y ; GET CHARACTER FROM SCREEN CMP #" "        ; CHECK FOR NORMAL DELETE BNE DOBDEL ; NO, DO BLACKHOLE DELETE INY ; INC TO TEST ENTIRE LINE CPY MAXLIN ; CHECK IF GONE OFF LINE BCC CHKDEL BEQ CHKDEL;SASDAV LDY TAB ; RESTORE TAB PLA ; KILL RETURN ADDRESS PLA JMP NMLDEL ; NOW DO A NORMAL DELETE;DOBDEL JSR SCOLOR ; SET COLOUR RAM POINTER LDY TAB ; RESTORE CURSOR TABDELOOP INY ; INC FOR NEXT CURSOR TAB CPY MAXLIN ; CHECK IF GONE OVER LINE LIMIT BEQ DONTEX ; LAST CHARACTER, DON'T EXIT YET BCS DONDEL ; YES, EXITDONTEX LDA (PNT),Y ; GET CHARACTER FROM SCREEN DEY ; GO BACK ONE TAB POSITION STA (PNT),Y ;...AND STORE IT THERE INY ; INC TO TRANSFER COLOUR LDA (COLPNT),Y ; GET COLOUR UNDER CHARACTER DEY ; DEC TO PLACE COLOUR STA (COLPNT),Y INY ; INC TO NORMAL TAB BNE DELOOP ; ALWAYS;DONDEL DEY ; MOVE Y TO LINEMAX POSITION LDA #" "        ; TO PUT A SPACE THERE STA (PNT),Y DEC INSRT ; DECREMENT NUMBER OF INSERTS BPL NOI ; CHECK IF GONE UNDER INC INSRT ; YES, RESTORE LOCATIONNOI RTS;;********************;*                  *;* DO F1, GO TO TAB *;*                  *;********************;DOF1 LDA TAB ; GET CURSOR COLOUMN CMP MAXLIN ; CHECK IF AT LAST LINE BEQ OKTAB ; YES, DON'T MOVE CURSORDOTAB CLC ; INC TO START AT NEXT TAB ADC #1 PHA ; SAVE LOCATION JSR DIVIDE ; CALCULATE TAB BIT AND TABS,X ; ISOLATE BIT TAX ; SAVE IT PLA ; RESTORE CURSOR TAB CPX #0 ; CHECK FOR A TAB BNE OKTAB ; TAB, SET IT CMP MAXLIN ; DID I GO OFF THE SCREEN BCC DOTAB ; NO, CONTINUE;OKTAB STA TAB ; SET FINAL TAB RTS;CALBIT LDA TAB ; CALCULATE TAB BITDIVIDE PHA ; SAV FOR LATER AND #7 ; ISOLATE 3 BITS TAY ; .Y ARE BITS+1 PLA ; RESTORE CURSOR TAB LSR A ; SHIFT TO FIND INDEXER LSR A LSR A TAX ; PUT THAT IN .X LDA #1SHFBIT DEY ; COUNT BIT SHIFTS BMI ENDCAL ASL A ; SHIFT UNTIL COUNTER DONE JMP SHFBIT;;******************;*                *;* DO F2, SET TAB *;*                *;******************;DOF2 JSR CALBIT ; CALCULATE TAB BIT EOR TABS,X ; FLIP TAB BIT STA TABS,X ; SAVE NEW TAB BITENDCAL RTS;;******************************;*                            *;* DO F3, DELETE AFTER CURSOR *;*                            *;******************************;DOF3 JSR SCOLOR ; SET COLOUR POINTER LDY TAB ; GET CURSOR TABNCLINR LDA #" " ; FILL WITH SPACES STA (PNT),Y LDA COLOUR ; RESET COLOUR STA (COLPNT),Y CPY MAXLIN ; GONE OFF ENTIRE LINE... INY BCC NCLINR ; NO, CONTINUE; RTS;;*******************************;*                             *;* DO F4, DELETE BEFORE CURSOR *;*                             *;*******************************;DOF4 JSR SCOLOR ; SET COLOUR POINTER LDY TAB ; GET CURSOR TABNCLINL LDA #" " ; FILL WITH SPACES STA (PNT),Y LDA COLOUR ; RESET COLOUR STA (COLPNT),Y DEY ; DEC FOR NEXT LOCATION BPL NCLINL ; MORE TO DO...; RTS;;************************************;*                                  *;* DO F5, DELETE RANGE AFTER CURSOR *;*                                  *;************************************;DOF5 JSR SCOLOR ; SET COLOUR POINTER LDY TAB ; SCAN FOR NON-SPACESCANSP LDA (PNT),Y ; GET CHARACTER FROM SCREEN CMP #" " ; CHECK FOR A SPACE BNE FNDSPZ INY CPY MAXLIN ; DONE SCANNING? BCC SCANSP;EXCLR RTS;FNDSPZ LDA #" " ; CLEAR SPOT WITH A SPACE STA (PNT),Y LDA COLOUR ; RESET COLOUR RAM STA (COLPNT),Y CPY MAXLIN BEQ EXCLR INY ; INC FOR NEXT LOCATION LDA (PNT),Y ; CHECK IF DONE RANGE CMP #" " BNE FNDSPZ; RTS;;*************************************;*                                   *;* DO F6, DELETE RANGE BEFORE CURSOR *;*                                   *;*************************************;DOF6 JSR SCOLOR ; SET COLOUR POINTER LDY TAB ; SCAN FOR NON-SPACESCANS2 LDA (PNT),Y ; GET CHARACTER FROM SCREEN CMP #" " ; CHECK FOR A SPACE BNE FNDSPY DEY BPL SCANS2; RTS;FNDSPY LDA #" " ; CLEAR SPOT WITH A SPACE STA (PNT),Y LDA COLOUR ; RESET COLOUR RAM STA (COLPNT),Y DEY ; INC FOR NEXT LOCATION BMI EXCLR LDA (PNT),Y ; CHECK IF DONE RANGE CMP #" " BNE FNDSPY; RTS;;******************************;*                            *;* DO F7, UPSIDEDOWN HOME KEY *;*                            *;******************************;DOF7 LDX #0 ; GO TO POSITION 0,... LDY #24 ;...24, BOTTOM, LEFT OF SCREEN STX TAB STY TBLX JSR DOF8 ; PERFORM ESCAPE AS WELL JMP STUPT ; RECALCULATE SCREEN ADDRESS;;*********************;*                   *;* DO F8, ESCAPE KEY *;*                   *;*********************;DOF8 AND #0 STA RVSFLG ; CLEAR REVERSE FLAG STA QTSW ; NOT IN QUOTE MODE STA INSRT ; AND NO INSERTS OUTSTANDING RTS;;***************************;*                         *;* CTRL-D, XOR DELETE MODE *;*                         *;***************************;CTRLD LDA #1 EOR DELFLG ; XOR BLACKHOLE DELETE FLAG STA DELFLG RTS;;*******************************;*                             *;* CTRL-P, PRINTER SCREEN DUMP *;*                             *;*******************************;CTRLP AND #0 ; CLEAR ST BYTE STA ST LDA PDEVC ; MAKE PRINTER LISTEN FOR DUMP JSR LISTEN LDA #$66 ; SEND SA ADDRESS, CHANNEL 6 JSR SALIST LDA ST ; CHECK ST BYTE BPL DOMP ; OK ST, CONTINUE WITH DUMP JMP UNLIST;DOMP LDA PNT ; PUSH PNT ADDRESS PHA LDA PNT+1 PHA LDA HIBASE STA PNT+1 ; SET POINTER TO HOME POSITION AND #0 STA PNT LDA #24 ; 25 LINES TO DO... STA TEMPA LDA MAXLIN ; SAVE MAXLIN LENGTH PHA LDA #39 ; SET MAXLIN TO 40 CHARACTERS STA MAXLIN LDA #22 ; SET 144/22 LINES PER INCH JSR OBYTE JSR UNLIST LDA PDEVC ; CHANNEL 6 OK, SET CHANNEL 0 JSR LISTEN LDA #$70 JSR SALISTDUMPSC JSR OUTLN1 ; OUTPUT THE LINE... JSR AWSHIT BCC AKS LDA #13 ; BLANK LINE, PRINT A RETURN JSR OBYTEAKS LDA PNT ; ADD 40 TO POINTER CLC ADC #40 STA PNT LDA PNT+1 ; ALSO DO HIGH BYTE ADC #0 STA PNT+1 DEC TEMPA ; DONE WHOLE SCREEN? BPL DUMPSC; JSR UNLIST LDA PDEVC JSR LISTEN LDA #$66 ; RESET LINES PER INCH JSR SALIST LDA #24 ;...6 LINES PER INCH JSR OBYTE PLA ; RESTORE MAXLIN VALUE STA MAXLIN PLA ; RESTORE PNT ADDRESS STA PNT+1 PLA STA PNT JMP UNLIST>; .FILE STRINGMON.4