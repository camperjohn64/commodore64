;**********************************;**                              **;**    COMMODORE 64 ASSEMBLER    **;**       CROSS REFERENCE        **;**                              **;** UNASSEMBLED AND COMMENTED BY **;**         PETER SLAN.          **;**                              **;**********************************;;**********************************;*                                *;*            LABLES              *;*                                *;**********************************; ERRNUM=$02 ; TWO BYTES OF DISK ERROR WORKLO=$04 ; TEMPORARY WORK SPACE AT WORKHI=$05 ; END OF PROGRAM DECWOR=$06 ; POINTER TO DECIMAL WORK AREA LOAD=$08 ; TWO BYTE LOAD ADDRESS NXTDEC=$0A ; POINTER TO NEXT DECIMAL VALUE LOBYTE=$0C ; MISC. LOW POINTER HIBYTE=$0D ; MISC. HIGH POINTER DECPNT=$0E ; POINTER TO DECIMAL TABLE STRLO=$10 ; LOW BYTE TO STRING TO PRINT STRHI=$11 ; HIGH BYTE  TO STRING XTEMP=$12 ; .X REGISTER STORAGE YTEMP=$13 ; INDEX STOREAGE TEMSTA=$14 ; TEMPORARY I/O STATUS FLAG=$15 ; END OF DECIMAL FLAG OFFSET=$16 ; TWO BYTE LOAD ADDRESS OFFSET OFF2=$18 ; TWO BYTE SECOND OFFSET ST=$90 ; I/O STATUS; BUFFER=$0200 ; RAM BUFFER FOR DECIMAL WORK VICII=$D011 ; VICII CHIP CONTROL REGISTER BASIC=$E386 ; BASIC WARM START OUTPUT=$E716 ; OUTPUT TO SCREEN; SETLFS=$FFBA ; SET UP A LOGICAL FILE SETNAM=$FFBD ; SET UP FILENAME OPEN=$FFC0 ; OPEN A FILE CLOSE=$FFC3 ; CLOSE A FILE CHKIN=$FFC6 ; MAKE FILE AN INPUT CHANNEL CHKOUT=$FFC9 ; MAKE FILE AN OUTPUT CHANNEL CLRCHN=$FFCC ; CLEAR ALL CHANNELS INPUT=$FFCF ; INPUT FROM KEYBOARD/DEVICE PRINT=$FFD2 ; PRINT TO SCREEN/DEVICE; *=$0801; .BYTE 14,8,10,0,158 .BYTE ' (2064)',0,0,0; JSR TRZER ; SAVE ZERO PAGE FOR LATER JMP START ; START MAIN PROGRAM;TEMPS *=*+24FILE *=*+1 ; CURRENT DISK FILETEMPS2 *=*+1TEMPS3 *=*+1SCREEN *=*+1 ; SCREEN AND PRINTER FLAGPAGNUM *=*+2 ; CURRENT PAGE #RETFLG *=*+1 ; # OF RETURNS TO PRINTNAME *=*+13 ; FILENAME GOES HEREUNUSED *=*+3 ; UNUSED, IT SORTA JUST EXISTSFILOUT *=*+5 ; OUTPUT NAME, ALSO USES "NAME2"NAME2 *=*+13 ; ANOTHER FILENAME GOES HERENUMLOP *=*+1 ; # OF LOOPS TO MAKETEMP13 *=*+1LOPVAL *=*+1 ; LOOP VALUE (ANOTHER "NUMLOP")ERROR *=*+50 ; MISC. ERROR CHANNEL STUFF;; CLEAR TEMPORARY STUFF;START CLD ; CLEAR DECIMAL MODE LDA #0 STA RETFLG ; CLEAR # OF RETURNS TO PRINT STA PAGNUM ; CLEAR PAGE # LOW STA PAGNUM+1 ; CLEAR PAGE # HIGH INC PAGNUM ; PAGE NUMBER IS 1 STA FILE ; CLEAR DISK FILE FLAG STA OFF2 STA OFF2+1;; OPEN FILES AND DISPLAY TITLE; LDA #5 ; FILE #5 LDX #0 ; DEVICE 0 (KEYBOARD) LDY #255 ; NO COMMAND JSR SETLFS ; SET UP FILE LDA #0 JSR SETNAM ; NO FILENAME JSR OPEN ; OPEN FILE LDA #1 ; FILE #1 LDX #3 ; DEVICE 3 (SCREEN) LDY #255 ; NO COMMAND JSR SETLFS ; SET UP FILE LDA #0 JSR SETNAM ; NO FILENAME JSR OPEN ; OPEN FILE LDA #147 JSR PRINT ; CLEAR SCREEN LDX #5 ; SET FOR FILE NUMBER 5 STX FILE JSR CHKIN ; ALL INPUT FROM KEYBOARD, #5 LDA #>TITLE LDY #<TITLE JSR STRING ; PRINT TITLE JSR INPUT ; INPUT FROM KEYBOARD LDX #0 STX SCREEN CMP #'N'        ; IS IT A "N"? BEQ NOHARD ; YES, NO HARDCOPY LDX #128NOHARD STX SCREEN LDA #4 ; FILE #4 TAX ; DEVICE 4 (PRINTER) LDY #255 ; NO COMMAND JSR SETLFS ; SET UP FILE LDA #0 JSR SETNAM ; NO FILENAME JSR OPEN ; OPEN FILE JSR BLANK ; BLANK THE SCREEN LDA #13 JSR PRINT ; LEAVE A LINE LDA #7 ; FILE #7 LDX #8 ; DEVICE 8 (DISK) LDY #15 ; SET FOR COMMAND CHANNEL JSR SETLFS ; SET UP FILE LDA #'I' ; INITIALIZE COMMAND STA ERROR LDA #'0'        ;...TO DRIVE ZERO STA ERROR+1 LDX #<ERROR ; LOW POINTER LDY #>ERROR ; HIGH POINTER LDA #2 ; LENGTH OF FILENAME JSR SETNAM ; SET UP FILENAME JSR OPEN ; OPEN FILE LDA #0 LDY #2 STA TEMPS2 STY TEMPS3 LDY #0 ; # OF CHARS.GETNAM LDA OUTFIL,Y ; GET NEXT CHAR. OF FILENAME STA FILOUT,Y ; SAVE IT INY ; INCREMENT # OF CHARS. CPY #14 ; 14 CHARS. YET? BNE GETNAM ; NO, GET MORE JSR PRCR2 JSR CLRCHN ; RESTORE DEFAULT I/O LDA #8 ; FILE #8 TAX ; DEVICE 8 (DISK) TAY ; SA 8 JSR SETLFS ; SET UP FILE LDX #<INFILE ; LOW POINTER TO FILENAME LDY #>INFILE ; HIGH POINTER TO FILENAME LDA #14 ; 14 CHARS. IN FILENAME JSR SETNAM ; SET FILENAME JSR OPEN ; OPEN FILE JSR STATUS ; PRINT DISK STATUS;;    SET UP POINTERS ETC.;SETUP LDA OFF2 LDY OFF2+1 STA OFFSET STY OFFSET+1 CLC  LDA OFFSET ADC TEMPS2 STA OFF2 LDA OFFSET+1 ADC TEMPS3 STA OFF2+1 LDA #<END LDY #>END ; GET END OF PROGRAM STA WORKLO ; AND SET IT AS A POINTER STY WORKHI LDA #<BUFFER LDY #>BUFFER ; GET START OF DECIMAL BUFFER STA DECWOR ; AND SET IT AS A POINTER STY DECWOR+1 LDA WORKLO LDY WORKHI ; GET POINTER (END OF PROGRAM) STA LOBYTE ; AND COPY IT TO THIS POINTER STY HIBYTE LDY #0 ; CLEAR OFFSETERASE TYA ; ERASE WITH ZEROS STA (LOBYTE),Y ; ERASE CURRENT BYTE INC LOBYTE ; INCREMENT LOW BYTE BNE LEAVHI ; INCRREMENT THE HIGH BYTE? INC HIBYTE ; YEP, INCREMENT ITLEAVHI LDA HIBYTE ; CHECK HIGH BYTE CMP DECWOR+1 ; DONE YET? BNE ERASE ; NO, KEEP ERASING LDA LOBYTE ; CHECK LOW BYTE CMP DECWOR ; DONE YET? BNE ERASE ; NO, KEEP ERASING; LDY #13 ; 14 CHARS. IN FILENAMEDECLOP LDA FILOUT,Y ; GET CHAR. OF FILENAME STA NAME,Y ; TRANSFER IT DEY ; DECREMENT COUNTER BPL DECLOP ; NOT DONE, KEEP TRANSFERING; LDA #82 STA UNUSED LDX #4INCLOP INC NAME2,X LDA NAME2,X CMP #':'        ; 0-9? BNE NEWFIL ; NO, OPEN NEW FILES LDA #'0' STA NAME2,X DEX  BNE INCLOP;;  OPEN NEW FILES (#9 AND #10);NEWFIL LDA #9 ; FILE #9 LDX #8 ; DEVICE 8 (DISK) TAY ; SA 8 JSR SETLFS ; SET UP FILE LDX #<NAME ; FILENAME LOW LDY #>NAME ; FILENAME HIGH LDA #14 ; 14 CHARS. IN FILENAME JSR SETNAM ; SET UP FILENAME JSR OPEN ; OPEN FILE JSR STATUS ; PRINT DISK STATUS LDA #10 ; FILE #10 LDX #8 ; DEVICE 8 (DISK) TAY ; SA 8 JSR SETLFS ; SET UP FILE LDX #<NAME2 ; FILENAME LOW LDY #>NAME2 ; FILENAME HIGH LDA #14 ; 14 CHARS. IN FILENAME JSR SETNAM ; SET UP FILENAME JSR OPEN ; OPEN FILE JSR STATUS ; PRINT DISK STATUS LDA #0 STA FLAGSETFIL LDX #9 CPX FILE ; IS FILE #9 INPUT FILE? BEQ FIL9IN ; YES, INPUT FROM IT STX FILE JSR CLRCHN ; CLEAR ALL CHANNELS LDX #9 JSR CHKIN ; ALL INPUT FROM FILE #9FIL9IN JSR INPUT ; INPUT LOAD ADDRESS LOW STA LOAD ; SAVE IT JSR INPUT ; INPUT LOAD ADDRESS HIGH STA LOAD+1 ; SAVE IT JSR INPUT ; GET LOW BYTE TO NEXT DECIMAL STA NXTDEC ; SAVE IT JSR INPUT ; GET HIGH BYTE TO NEXT DECIMAL STA NXTDEC+1 ; SAVE IT LDA ST ; GET CURRENT I/O STATUS STA FLAG ; SAVE IT SEC  LDA LOAD SBC OFFSET LDA LOAD+1 SBC OFFSET+1 BCC NOTOFF LDA LOAD SBC OFF2 LDA LOAD+1 SBC OFF2+1 BCC DECMAL ; PRINT IT IN DECIMALNOTOFF JSR CLRCHN LDX #10 STX FILE JSR CHKOUT ; MAKE ALL OUTPUT GO TO FILE #10 LDA LOAD ; GET LOAD ADDRESS LOW JSR PRINT ; PRINT IT TO FILE LDA LOAD+1 ; GET LOAD ADDRESS HIGH JSR PRINT ; PRINT IT TO FILE LDA NXTDEC ; GET LOW BYTE TO NEXT DECIMAL JSR PRINT ; PRINT IT TO FILE LDA NXTDEC+1 ; GET HIGH BYTE TO NEXT DECIMAL JSR PRINT ; PRINT IT TO FILE JMP NOHIGH ; DO MAIN LOOP;;  CONVERT A BYTE TO DECIMAL;DECMAL SEC  LDA LOAD SBC OFFSET STA LOBYTE LDA LOAD+1 SBC OFFSET+1 ASL LOBYTE ; DOUBLE LOW BYTE ROL A ; OFFSET FOR HIGH BYTE ASL LOBYTE ; DOUBLE AGAIN ROL A ; ALSO HIGH BYTE, NOW IT'S *4 STA HIBYTE ; SAVE HIGH BYTE CLC ; CLEAR CARRY FOR ADD LDA LOBYTE ; ADD VALUE * 4... ADC WORKLO ; TO ORIGINAL VALUE STA LOBYTE ; STORE RESULT HERE LDA HIBYTE ADC WORKHI ; ADD THE HIGH BYTES STA HIBYTE ; STORE RESULT LDY #1 ; OFFSET IS ONE LDA (LOBYTE),Y ; CHECK BYTE; IS IT DECIMAL? BNE NOZERO ; NO, MAKE IT DECIMAL DEY ; OFFSET IS ZERO LDA DECWOR ; GET DECIMAL WORK STA (LOBYTE),Y ; SAVE IT INY ; OFFSET IS ONE LDA DECWOR+1 ; GET DECIMAL WORK STA (LOBYTE),Y ; SAVE IT INY ; OFFSET IS TWO LDA DECWOR ; GET DECIMAL WORK STA (LOBYTE),Y ; SAVE IT INY ; OFFSET IS THREE LDA DECWOR+1 ; GET DECIMAL WORK STA (LOBYTE),Y ; SAVE IT BNE NEXT ; BRANCH ALWAYS;NOZERO DEY ; OFFSET IS ZERO LDA (LOBYTE),Y ; GET BYTE STA DECPNT ; PUT IT IN DECIMAL POINTER LOW INY ; OFFSET IS ONE LDA (LOBYTE),Y ; GET BYTE STA DECPNT+1 ; PUT IT IN DECIMAL POINTER HIGH LDA DECWOR+1 ; GET OTHER DECIMAL WORK STA (LOBYTE),Y ; SAVE IT IN TABLE STA (DECPNT),Y ; SAVE IT IN DECIMAL TABLE DEY ; OFFSET IS ZERO AGAIN LDA DECWOR ; GET SOME MORE DECIMAL WORK STA (LOBYTE),Y ; STORE IT IN TABLE STA (DECPNT),Y ; STORE IT IN DECIMAL TABLENEXT LDY #1 LDA #0 STA (DECWOR),Y ; KILL 2ND BYTE OF TABLE INY ; OFFSET IS TWO LDA NXTDEC ; GET NEXT WORK STA (DECWOR),Y ; STORE IT IN DECIMAL TABLE INY ; OFFSET IS THREE LDA NXTDEC+1 ; GET NEXT WORK STA (DECWOR),Y ; STORE IT IN DECIMAL TABLE CLC ; CLEAR CARRY FOR ADD LDA DECWOR ADC #4 ; ADD FOUR STA DECWOR ; RE-SAVE IT, OVERFLOW? BCC NOHIGH ; NO, LEAVE HIGH BYTE ALONE INC DECWOR+1 ; ADD ONE TO HIGH BYTENOHIGH LDA FLAG ; END YET? BNE MAIN ; YES, DO MAIN ROUTINE JMP SETFIL ; OPEN FILES, REPEAT;;   MAIN CROSS REFERENCE LOOP;MAIN LDA #9 JSR CLOSE ; CLOSE FILE #9 LDA #10 JSR CLOSE ; CLOSE FILE #10MAIN1 LDY #1 LDA (WORKLO),Y ; GET CURRENT VALUE LDY #3 CMP (WORKLO),Y ; CROSS REFERENCE IT? BNE SPACE ; NO, LEAVE A SPACE LDY #0 LDA (WORKLO),Y ; GET CURRENT VALUE LDY #2 CMP (WORKLO),Y ; CROSS REFERENCE IT? BNE SPACE ; NO, LEAVE A SPACE LDA #42 BNE PRNTIT ; BRANCH ALWAYS;SPACE LDA #' '   ; GET A SPACE CHARACTERPRNTIT JSR DIGPRT ; PRINT IT... JSR PRTSPC ;...TWICE LDY #6 ; WE'RE GOING TO LOOP 6 TIMESLOOP7 JSR DISKIN ; GET BYTE FROM FILE JSR DIGPRT ; PRINT THE BYTE DEY ; DONE 7 BYTES YET? BNE LOOP7 ; NO, LOOP BACK; JSR PRTSPC ; PRINT A SPACE LDA #'$'        ; WE'RE GOING TO PRINT IN HEX JSR DIGPRT ; SO PRINT A "$" JSR DISKIN ; "CHKIN" AND GET A BYTE JSR HEXOUT ; PRINT BYTE IN HEX JSR DISKIN ; "CHKIN" AND GET A BYTE LDX ST ; GET CURRENT I/O STATUS STX TEMSTA ; SAVE IT JSR HEXOUT ; PRINT HEX DIGIT FROM .A LDY #2 LDA (WORKLO),Y ; GET CURRENT VALUE LOW TAX ; SAVE IT IN .X INY ; OFFSET IS THREE LDA (WORKLO),Y ; GET CURRENT WORK VALUE HIGH STX LOBYTE ; SAVE NEW LOW BYTE STA HIBYTE ; SAVE NEW HIGH BYTE BNE RELOOP ; SET UP AND RE-LOOPLOOP JSR PRTSPC ; PRINT A SPACE LDY #2 LDA (LOBYTE),Y ; GET NEW VALUE TAX ; SAVE IT IN .X INY ; OFFSET IS THREE LDA (LOBYTE),Y ; GET NEXT NEW VALUE JSR SUBLOP LDY #1 LDA (LOBYTE),Y ; GET NEXT VALUE (OFFSET ONE) TAX ; IT BECOMES NEW HIGH POINTER BEQ EXIT ; X=0, EXIT FROM LOOP DEY ; OFFSET IS ZERO LDA (LOBYTE),Y ; NEXT VALUE IS A NEW POINTER STA LOBYTE ; SAVE NEW LOW BYTE STX HIBYTE ; SAVE NEW HIGH BYTE DEC NUMLOP ; DECREMENT LOOP NUMBER BNE LOOP ; LOOP NOT DONE, KEEP LOOPING; JSR PRCR1 LDX #7 ; WE'RE GONNA PRINT 8 TIMESLOOP2 JSR TWOSPC ; PRINT TWO SPACES DEX ; DONE OUR 8 PRINTS YET? BNE LOOP2 ; NO, LOOP AND PRINT AGAIN;RELOOP LDY #10 ; LOVE THE LABEL "RELOOP" EH! STY NUMLOP ; WE'RE GONNA LOOP 11 TIMES BNE LOOP ; BRANCH ALWAYS; LOOP AGAINEXIT JSR PRCR1 ; PRINT NEW HIGH POINTER LDA TEMSTA ; GET OLD I/O STATUS BNE PRTQUT ; NOT OK, PRINT ERROR CLC ; CLEAR THE CARRY BEFORE ADDITION LDA WORKLO ; GET TEMP. WORK LOW ADC #4 ; ADD 4 (WHY?) STA WORKLO ; SAVE NEW VALUE; OVERFLOW? BCC NOTHI ; NO, LEAVE HIGH BYTE ALONE INC WORKHI ; OVERFLOW, INCREMENT HIGH BYTENOTHI SEC ; SET THE CARRY BEFORE SUB LDA WORKLO ; GET TEMP. WORK LOW BYTE SBC #170 ; SUBTRACT 170 (WHY?) LDA WORKHI ; GET TEMP. WORK HIGH BYTE SBC #21 ; SUBTRACT 21, OVERFLOW OF PREVIOUS? BCS CLEAR ; YES, SUBTRACT CARRY (1) JMP MAIN1;CLEAR JSR CLRCHN ; CLEAR ALL CHANNELS JMP SETUP ; SET UP POINTERS ETC.;PRTQUT JSR PRCR JSR PRCR ; PRINT OLD I/O STATUS LDA #4 JSR CLOSE ; CLOSE FILE #4 LDA #8 JSR CLOSE ; CLOSE FILE #8 JSR CLRCHN ; CLEAR ALL CHANNELS JMP QUIT ; QUIT PROGRAM, RETURN TO BASIC;; SET INPUT DEVICE FOR FILE AND INPUT A BYTE;DISKIN LDX #8 CPX FILE ; IS IT ALREADY AN INPUT FILE? BEQ INBYTE ; YES, INPUT A BYTE STX FILE JSR CLRCHN ; RESTORE DEFAULT I/O LDX #8 JSR CHKIN ; ALL INPUT FROM DISK FILEINBYTE JMP INPUT ; INPUT A BYTE;; CALCULATE SOME STRANGE VALUES;SUBLOP STX STRLO ; SAVE STUFF FOR FURTHER USE STA STRHI LDA #0 STA TEMP13 LDX #4 STX LOPVAL ; LOOP 5 TIMES,OFFSET OF "DECLO"AGAIN LDX LOPVAL LDY #48 BNE SUBTRC ; BRANCH ALWAYS;INCTEM INY STY TEMP13SUBTRC SEC ; SET CARRY FOR SUBTRACTION LDA STRLO ; GET LOW VALUE SBC DECLO,X ; SUBTRACT TABLE+OFFSET STA STRLO ; SAVE NEW VALUE LDA STRHI ; GET HIGH VALUE SBC DECHI,X ; SUBTRACT SECOND DECHI+OFFSET STA STRHI ; SAVE NEW VALUE, OVERFLOW? BCS INCTEM ; NO, INCREMENT LDA STRLO ; GET LOW VALUE ADC DECLO,X ; ADD FROM "DECLO"+OFFSET STA STRLO ; SAVE NEW VALUE LDA STRHI ; GET HIGH VALUE ADC DECHI,X ; ADD FROM "DECHI"+OFFSET STA STRHI ; SAVE NEW VALUE TYA ; TRANSFER .Y TO .A CMP #48 BNE PRIT LDY TEMP13 ; AT ZERO? BNE PRIT ; NO, PRINT IT VALUE LDA #' '        ; GET A SPACE CHARACTERPRIT JSR DIGPRT ; PRINT IT DEC LOPVAL ; DECREMENT LOOP; AT ZERO? BPL AGAIN ; NO, LOOP AGAIN; RTS ; RETURN FROM SUBROUTINE;RETURN LDA #13 ; GET A CARRIAGE RETURN JMP DIGPRT ; PRINT IT AND RETURN;;     OUTPUT A SINGLE DIGIT;TWOSPC JSR PRTSPC ; PRINT A SPACESPRTSPC LDA #' ' ; GET A SPACE CHARACTERDIGPRT STX XTEMP ; SAVE .X REGISTER STY YTEMP ; SAVE .Y REGISTER PHA ; SAVE CHARACTER BIT SCREEN BPL OUTDIG ; OUTPUT CHARACTER TO SCREEN LDA FILE CMP #4 ; OUTPUT TO PRINTER? BEQ PRTDIG ; NO, SCREEN JSR CLRCHN ; CLEAR ALL CHANNELS LDX #4 STX FILE JSR CHKOUT ; MAKE ALL OUTPUT GO TO PRINTERPRTDIG PLA ; RESTORE CHARACTER PHA ; SAVE CHARACTER JSR PRINT ; PRINT CHARACTER JMP RESPOI ; RESTORE POINTERS;OUTDIG JSR OUTPUT ; PRINT CHARACTER ON SCREENRESPOI PLA ; RESTORE CHARACTER LDY YTEMP ; RESTORE .Y REGISTER LDX XTEMP ; RESTORE .X REGISTER RTS;; GET DISK STATUS AND PRINT IT;STATUS JSR CLRCHN ; RESTORE DEFAULT I/O LDX #7 STX FILE JSR CHKIN ; ALL INPUT COMES FROM DISK ERROR CHANNEL JSR INPUT ; GET ERROR # STA ERRNUM ; SAVE IT JSR INPUT STA ERRNUM+1 CMP #'0' BNE GETMSG ; GET ERROR MESSAGE LDA ERRNUM CMP #'0' BNE GETMSG ; GET ERROR MESSAGEWAITCR JSR INPUT ; WAIT FOR A CARRIAGE RETURN CMP #13 ; IS IT ONE? BNE WAITCR ; NO, KEEP WAITING RTS ;GETMSG LDX #1TRANST LDA ERRNUM,X ; GET ERROR # STA ERROR,X ; TRANSFER IT DEX ; ALL NUMBERS? BPL TRANST ; NO; LDY #2 ; INDEXER IS TWOINMSG STY YTEMP ; STORE IT IN .Y TEMPORARY JSR INPUT ; GET NEXT CHAR OF MESSAGE CMP #13 ; HAVE I ALL CHARS? BEQ PRMSG ; YES, PRINT MESSAGE LDY YTEMP ; NO, GET INDEXER AGAIN STA ERROR,Y ; SAVE CHAR IN "ERROR"+INDEX INY ; INCREMENT INDEXER BNE INMSG ; BRANCH ALWAYS;PRMSG LDA #141 ; SHIFTED CARRIAGE RETURN... STA ERROR,Y ; IS LAST CHAR. LDA #>ERROR LDY #<ERROR JSR STRING ; PRINT STATUS MESSAGE STRINGQUIT JSR UNBLNK ; MAKE SCREEN VISIBLE NOW JSR TRTEMP ; TRANSFER TEMPORARY TO ZPAGE JMP BASIC ; END OF PROGRAM; BACK TO BASIC;;  PRINT A STRING FROM .A, .Y;STRING PHA ; SAVE HIGH BYTE POINTER LDA #1 CMP FILE ; PRINT TO PRINTER? BEQ STRPRT ; YES TYA PHA ; SAVE LOW BYTE POINTER JSR CLRCHN ; RESTORE DEFAULT I/O LDX #1 STX FILE ; SET UP FOR SCREEN JSR CHKOUT ; MAKE OUTPUT GO TO SCREEN FILE PLA ; RESTORE LOW BYTE POINTER TAY STRPRT PLA ; RESTORE HIGH BYTE POINTER STA STRHI ; SAVE HIGH POINTER STY STRLO ; SAVE LOW POINTER LDY #0 ; CLEAR STRING CHAR. COUNTPRTBYT LDA (STRLO),Y ; GET NEXT BYTE OF STRING INY ; INCREMENT STRING CHAR. COUNT PHA ; SAVE BYTE AND #127 JSR PRINT ; PRINT BYTE PLA ; RESTORE BYTE; IS IT ZERO? BPL PRTBYT ; NO, MORE BYTES TO PRINT; RTS ;; OUTPUT HEX BYTE IN ACCUMULATOR;HEXOUT PHA ; SAVE HEX BYTE LSR A ; EXTRACT... LSR A ; FOUR... LSR A ; LOWER... LSR A ; BITS... JSR HEXPR ; AND PRINT THEM PLA ; RESTORE HEX BYTE AND #15 ; EXTRACT 4 UPPER BITSHEXPR CLC ADC #'0' CMP #':'        ; GREATER THAN '9'+1? BMI PRCHAR ; NO, PRINT CHARACTER CLC  ADC #7 ; IT'S A LETTERPRCHAR JMP DIGPRT ; PRINT DIGIT;; PRINT CARRIAGE RETURNS;PRCR JSR RETURN ; PRINT A SINGLE RETURN INC RETFLG LDA RETFLG CMP #66 ; ALL RETURNS PRINTED? BNE PRCR ; NO, PRINT ANOTHER; LDA #0 STA RETFLG ; CLEAR RETURN FLAG RTS ;PRCR1 JSR RETURN INC RETFLG ; INCREMENT # OF RETURNS TO PRINT LDA RETFLG CMP #60 ; 60 RETURNS (1 FULL PAGE) BNE DONE ; NOPE, KEEP DOING CROSS REFERENCE JSR PRCR ; PRINT CARRIAGE RETURNSPRCR2 JSR PRCR1 ; SKIP TO NEXT PAGE TXA  PHA ; SAVE BYTE;; PRINT CROSS REFERENCE PAGE NUMBER; LDX #0CRPAG LDA PAGE,X ; GET CHAR. FROM MESSAGE BEQ NXTPAG ; ZERO, START NEXT PAGE JSR DIGPRT ; PRINT CHAR. INX  BNE CRPAG ; BRANCH ALWAYS;; START NEXT CROSS REFERENCE PAGE;NXTPAG LDX PAGNUM LDA PAGNUM+1 JSR SUBLOP INC PAGNUM ; INCREMENT LOW BYTE BNE NOTZER ; NOT ZERO, DON'T TOUCH HIGH INC PAGNUM+1 ; INCREMENT HIGH BYTENOTZER JSR PRCR1 JSR PRCR1 ; LEAVE SOME SPACE ON THE PAGE JSR PRCR1 PLA  TAXDONE RTS;;        ASCII STRINGS;TITLE .BYTE 147,13,'CROSS REFERENCE' .BYTE 13,13,13,'HARD COPY' .BYTE ' (CR/Y OR N)?',160;INFILE .BYTE '0:XRLL0000,S,R';OUTFIL .BYTE '0:XRFF0000,S,W';PAGE .BYTE 'CROSS REFERENCE' .BYTE '.....PAGE',0;; DECIMAL CONVERSION TABLES;DECLO .BYTE <1,<10,<100,<1000,<10000DECHI .BYTE >1,>10,>100,>1000,>10000;;     BLANK THE SCREEN;BLANK LDA SCREEN ; IS SCREEN ALREADY BLANK? BPL NOBLNK ; YES, DON'T BLANK IT AGAIN LDA VICII ; GET VIC CHIP JUNK AND #$FF-$10 ; CLEAR 4'TH BIT STA VICII ; WOW! WE BLANKED THE SCREENNOBLNK RTS;;      UN-BLANK THE SCREEN;UNBLNK LDA VICII ; GET VIC CHIP JUNK ORA #16 ; SET BIT 5 STA VICII ; SCREEN NOT BLANKED (TOO BAD) RTS ;; TRANSFER STUFF FROM ZERO PAGE INTO TEMPORARY;TRZER LDX #24TRLOP1 LDA HIBYTE,X ; GET ZERO PAGE BYTE STA TEMPS,X ; SHOVE IT IN TEMPORARY DEX ; ALL DONE? BPL TRLOP1 ; NO, TRANSFER AGAIN; RTS;; TRANSFER TEMPORARY STUFF INTO ZERO PAGETRTEMP LDX #24TRLOP2 LDA TEMPS,X ; GET TEMP. BYTE STA ERRNUM,X ; SHOVE IT ON ZERO PAGE DEX ; ALL DONE? BPL TRLOP2 ; NO, TRANSFER AGAIN; RTS ;; WHAT A TERRIFIC JOB PETER DID OF; UNASSEMBLING AND COMMENTING THIS; USELESS  PROGRAM.  THANKS PETER!;END .END