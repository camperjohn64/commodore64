 .PAGE "EDITOR.5";****************************************************;*                                                  *;*                    RTC EDITOR REL                *;*                                                  *;* COMMAND LIST FOR PART 5                          *;*                                                  *;* NEW BASIN ROUTINE                                *;* SCROLL UP/DOWN                                   *;* FUNCTION KEYS                                    *;* FORMATED OUTPUT                                  *;*                                                  *;****************************************************;;  NEW BASIN ROUTINE;BASIN LDA DFLTN ; CHECK FOR INPUT FROM KEYBOURD BEQ BASIN2JBASIN JMP $FFFF ; GETS MODIFIED;BASIN2 LDA PNTR STA LXSP+1 LDA TBLX STA LXSP TYA PHA TXA PHA LDA CRSW BNE TOLOP5 TSX ; SET X TO STACK POINTER LDA STACK+7,X ; GET LOW BYTE RETURN ADDRESS CMP #<MAIN-7 ; WILL I RETURN TO "MAIN" BNE TOLOP3 ; NOPE, DO NORMAL INPUT LDA STACK+8,X ; MAYBE, GET HIGH BYTE CMP #>MAIN ; CHECK IT TOO BEQ BASIN4 ; OK, DO SPECIAL INPUT ROUTINETOLOP3 JMP LOOP3 ; SOMETHINS NOT RIGHT, EXIT;BASIN3 JSR DOPRTBASIN4 LDA NDX ; GET KEYBOURD BUFFER LENGTH STA BLNSW ; SAVE NUMBER OF CHARACTERS STA AUTODN ; IN HERE BEQ BASIN4 ; WAS IT ZERO?; SEI ; NO, HE PRESSED SOMETHING LDA BLNON ; GET CURSOR ON/OFF POSITION BEQ BASIN5 LDA GDBLN ; CURSOR WAS ON LDX GDCOL LDY #0 ; SO SWITCH IT OFF STY BLNON JSR DSPPBASIN5 JSR LP2 ; INPUT CHARACTER CMP #CR ; WAS IT A RETURN? BNE BASIN3 ; NO, PRINT CHARACTER; STA OLDFLG ; YES, GET READY TO EXIT LDY LNMX ; GET MAXIMUM LINE LENGTH (40) STY CRSWBASIN6 LDA (PNT),Y ; GET CHARECTER CMP #" " ; COMPARE IT WITH A SPACE BNE BASIN7 ; NOT A SPACE, END OF LINE FOUND DEY ; GO FOR NEXT CHARACTER TO LEFT BNE BASIN6;BASIN7 INY ; END OF LINE FOUND STY INDX ; SAVE IT HERE LDY #0 STY AUTODN STY PNTR STY QTSW LDA LXSP ; GET X POSITION OF INPUT BMI TOLOP5 LDX TBLX JSR FINDST CPX LXSP BNE TOLOP5 LDA LXSP+1 STA PNTR CMP INDX BCC TOLOP5 JMP CLP2;TOLOP5 JMP LOP5;; DO PRINT ROUTINE;DOPRT PHA ; SAVE A STA TDAT3 TXA ; AND SHOVE X AND Y ON STACK PHA TYA PHA LDA TDAT3 ; RE-LOAD CHARACTER LDX #DOCHRL-CHRS-1NCKCHR CMP CHRS,X ; CHARACTER A SPECIAL KEY? BEQ DOCHR ; YEP, DO THAT CHARECTER DEX ; NO, CHECK OTHER CHARACTERS BPL NCKCHR;DOPRT2 LDA FNBYTE ; GET CURRENT MODE AND #ISON ; PLUCK OFF INSERT BIT BEQ DOPRT3 ; NOT IN INSERT MODE LDA QTSW ; YEA, INSERT MODE IS ON PHA ; SO SHOVE STUFF ON STACK.. LDA INSRT PHA JSR DOINS ; THEN "INSERT" PLA ; PULL STUFF BACK OFF STACK STA INSRT PLA STA QTSW ;...AND CONTINUE AS NORMALDOPRT3 LDA TDAT3 JMP PRINT2 ; FINALY PRINT THE CHARACTER;DOCHR JSR DOCHR2 ; DO SPECIAL KEYNOCHR PLA ; RE-LOAD JUNK AND RETURN TAY PLA TAX PLA RTS;DOCHR2 LDA DOCHRH,X ; GET HIGH BYTE OF VECTOR PHA ; SHOVE IT ON THE STACK LDA DOCHRL,X ; NOW GET THE HIGH BYTE PHA ; SHOVE IT ON THE STACK TOO PHP ; PHP FOR RTI NOT RTS RTI ; RTI=PLP, RTS-1;CHRS .BYTE CRSRDN ; CURSOR DOWN .BYTE CRSRUP ; CURSOR UP .BYTE SHRUN ; NEW SHIFT/RUN FOR DISK .BYTE DELKEY ; BLACK HOLE DELETE .BYTE F1 ; GO TO TAB .BYTE F2 ; SET/CLEAR TAB .BYTE F3 ; DELETE BEFORE CURSOR .BYTE F4 ; DELETE AFTER CURSOR .BYTE F5 ; CLEAR INSERT MODE .BYTE F6 ; SET INSERT MODE .BYTE F7 ; UPSIDEDOWN CURSOR HOME .BYTE F8 ; ESCAPE KEY;DOCHRL .BYTE <DOCDN ; VECTORS FOR NEW KEYS .BYTE <DOCUP .BYTE <DOSRUN .BYTE <DODEL .BYTE <DOF1 .BYTE <DOF2 .BYTE <DOF3 .BYTE <DOF4 .BYTE <DOF5 .BYTE <DOF6 .BYTE <DOF7 .BYTE <DOF8;DOCHRH .BYTE >DOCDN .BYTE >DOCUP .BYTE >DOSRUN .BYTE >DODEL .BYTE >DOF1 .BYTE >DOF2 .BYTE >DOF3 .BYTE >DOF4 .BYTE >DOF5 .BYTE >DOF6 .BYTE >DOF7 .BYTE >DOF8;; INSERT A SPACE FOR CHARACTER;DOINS LDA TDAT3 TAX AND #$7F TAY CPY #CR BEQ DOIRET LDA QTSW ORA INSRT BEQ DOINS3 LDA INSRT BNE DOIRET CPX #20 BEQ DOIRETDOINS2 PHA PHA PHA JMP PRTINS;DOINS3 CPY #" " BCS DOINS2DOIRET RTS;; STOP, ERROR, AND BSOUT FOR LIST;TSTOP LDA #1TERROR RTS;TBSOUT CMP #CR BEQ TERROR JMP PRINT;; GO BACK A LINE;BACLIN SEC LDA LOWTR SBC #<$0104 STA INDEX1 LDA LOWTR+1 SBC #>$0104 STA INDEX1+1 LDY #$FFNBACLN INYBACLN2 LDA (INDEX1),Y BNE NBACLN INY LDA (INDEX1),Y CMP LOWTR BNE BACLN2 INY LDA (INDEX1),Y DEY CMP LOWTR+1 BNE BACLN2 TYA CLC ADC INDEX1 STA LOWTR LDA INDEX1+1 ADC #0 STA LOWTR+1 RTS;; LIST LINE AT LOWTR;LISTLN LDA IERROR LDY IERROR+1 STA OERROR STY OERROR+1 LDA ISTOP LDY ISTOP+1 STA OSTOP STY OSTOP+1 LDA #<TERROR LDY #>TERROR STA IERROR STY IERROR+1 LDA #<TSTOP LDY #>TSTOP STA ISTOP STY ISTOP+1 LDY #3 LDA (LOWTR),Y STA LINNUM+1 STA LINOLD+1 DEY ; Y=2 LDA (LOWTR),Y STA LINNUM STA LINOLD DEY ; Y=1 STY GARBFL LDA LOWTR STA OLDLTR LDA LOWTR+1 STA OLDLTR+1 LDA #0 STA PNTR STA OLDFLG JSR FORLST LDA #0 STA QTSW LDA OERROR LDY OERROR+1 STA IERROR STY IERROR+1 LDA OSTOP LDY OSTOP+1 STA ISTOP STY ISTOP+1 RTS;; SCROLL SCREEN UP;SCRLUP LDA LDTB1+1 ORA #$80 STA LDTB1+1 JSR SCROL JMP STUPT;; SCROLL SCREEN DOWN;SCRLDN LDX #0 JSR BMTLA LDA LDTB1 ORA #$80 STA LDTB1 JMP STUPT;; GET LAST LINE NUMBER; GOING UP;GETLNU LDX #24NGTLNU JSR GNUM BCC GNURET DEX BPL NGTLNUGNURET RTS;; GOING DOWN;GETLND LDX #0NGTLND JSR GNUM BCC GNDRET INX CPX #25 BCC NGTLNDGNDRET RTS;; GET THE NUMBER;GNUM LDA LDTB1,X BPL GTNUM2 AND #$7F STA TXTPTR+1 LDA LDTB2,X STA TXTPTR JSR CHRGO2 JSR TSTNUM BCS GTNUM2 JMP REDECN;GTNUM2 SEC RTS;PRGRAM LDY #0 LDA (TXTTAB),Y INY ORA (TXTTAB),Y RTS;; DO CURSOR DOWN;DOCDN LDA TBLX ; GET CURSOR Y POSITION CMP #24 ; IS IT ON THE LAST LINE? BEQ DOCDN3DOCDN2 PLA ; NO, DO A NORMAL PRINT PLA JMP DOPRT2;DOCDN3 LDA QTSW ; YES, CHECK FOR QUOTE OR ORA INSRT ;...INSERT MODES ON BNE DOCDN2 STA RVS ; ITS OK, CLEAR REVERSE FLAG JSR PRGRAM BEQ DOCDN2 LDA #1 STA KOUNT JSR GETLNU BCS DCDN3B LDA OLDFLG BNE DCDN3A LDA LINNUM CMP LINOLD BNE DCDN3A LDA LINNUM+1 CMP LINOLD+1 BNE DCDN3A LDA OLDLTR LDY OLDLTR+1 STA LOWTR STY LOWTR+1 BNE DOCDN4 ; BRANCH ALWAYS;DCDN3A JSR FNDLIN BCS DOCDN4 CPY #2 BCS DOCDN6DCDN3B LDA TXTTAB LDX TXTTAB+1 BNE DOCDN5 ; BRANCH ALWAYS;DOCDN4 LDY #1 LDA (LOWTR),Y BEQ DOCDN2 TAX DEY LDA (LOWTR),YDOCDN5 STA LOWTR STX LOWTR+1 INY LDA (LOWTR),Y BEQ DOCDN2DOCDN6 LDA PNTR PHA JSR SCRLUP LDA LDTB1+1 PHA ORA #$80 STA LDTB1+1 JSR OUTLIN PLA LDY LDTB1+24 BPL DOCDN7 STA LDTB1+1DOCDN7 PLA CMP #40 BCC DOCDN8 SBC #40 ; CARRY IS SETDOCDN8 STA PNTR JMP STUPT;;   DO CURSOR UP;DOCUP LDA TBLX BEQ DOCUP3DOCUP2 PLA PLA JMP DOPRT2;DOCUP3 LDA QTSW ORA INSRT BNE DOCUP2 STA RVS JSR PRGRAM BEQ DOCUP2 LDA #1 STA KOUNT JSR GETLND BCS DOCUP5 LDA OLDFLG BNE DOCUP4 LDA LINNUM CMP LINOLD BNE DOCUP4 LDA LINNUM+1 CMP LINOLD+1 BNE DOCUP4 LDA OLDLTR LDY OLDLTR+1 STA LOWTR STY LOWTR+1 BNE DOCUP6 ; BRANCH ALWAYS;DOCUP4 JSR FNDLIN BCS DOCUP6 CPY #2 BCS DOCUP6DOCUP5 SEC LDA VARTAB SBC #2 STA LOWTR LDA VARTAB+1 SBC #0 STA LOWTR+1DOCUP6 SEC LDA LOWTR SBC TXTTAB STA INDEX1 LDA LOWTR+1 SBC TXTTAB+1 ORA INDEX1 BCC DOCUP7 BEQ DOCUP7 JSR BACLIN LDA PNTR PHA JSR SCRLDN JSR OUTLIN LDA #0 STA TBLX PLA STA PNTR JMP STUPT;DOCUP7 JSR SCRLDN JMP STUPT;OUTLIN JSR LOCKUP JSR LOCKCR JSR LISTLN JMP UNLOCK;;  DO SHIFT RUN/STOP;DOSRUN LDX #0NDOSR1 LDA SRSTR1,X ; GET LOAD":* FROM TABLE JSR PRINT ; AND PRINT IT INX CPX #SRSTR2-SRSTR1 ;...AM I DONE PRINTING? BCC NDOSR1; SEI ; STOP IRQ'S FIRST LDX #SRSTR3-SRSTR2 ; YES, PUT RETURNS IN STX NDX ; SET TABLE LENGTHNDOSR2 LDA SRSTR2-1,X ; GET FROM TABLE STA KEYD-1,X ; AND SHOVE IN KEYBRD BUFFER DEX BNE NDOSR2; CLI ; ALLOW IRQ'S NOW RTS ; AND GO FOR IT!;SRSTR1 .BYTE "LOAD",34,":*"SRSTR2 .BYTE 13,"RUN",13SRSTR3;;   BLACKHOLE DELETE;DODEL LDY PNTR ; GET CURSOR TABCHKDEL LDA (PNT),Y ; GET CHARACTER FROM SCREEN CMP #" "        ; CHECK FOR NORMAL DELETE BNE DOBDEL ; NO, DO BLACKHOLE DELETE INY ; INC TO TEST ENTIRE LINE CPY LNMX ; CHECK IF GONE OFF LINE BCC CHKDEL BEQ CHKDEL; LDY PNTR ; RESTORE TAB PLA ; KILL RETURN ADDRESS PLA JMP NMLDEL ; NOW DO A NORMAL DELETE;DOBDEL JSR SCOLOR ; SET COLOUR RAM POINTER LDY PNTR ; RESTORE CURSOR TABDELOOP INY ; INC FOR NEXT CURSOR TAB CPY LNMX ; CHECK IF GONE OVER LINE LIMIT BEQ DONTEX ; LAST CHARACTER, DON'T EXIT YET BCS DONDEL ; YES, EXITDONTEX LDA (PNT),Y ; GET CHARACTER FROM SCREEN DEY ; GO BACK ONE TAB POSITION STA (PNT),Y ;...AND STORE IT THERE INY ; INC TO TRANSFER COLOUR LDA (USER),Y ; GET COLOUR UNDER CHARACTER DEY ; DEC TO PLACE COLOUR STA (USER),Y INY ; INC TO NORMAL TAB BNE DELOOP ; ALWAYS;DONDEL DEY ; MOVE Y TO LINEMAX POSITION LDA #" "        ; TO PUT A SPACE THERE STA (PNT),Y DEC INSRT ; DECREMENT NUMBER OF INSERTS BPL NOI ; CHECK IF GONE UNDER INC INSRT ; YES, RESTORE LOCATIONNOI RTS;; DO F1, GO TO TAB;DOF1 LDA PNTR ; GET CURSOR COLOUMN CMP LNMX ; CHECK IF AT LAST LINE BEQ OKTAB ; YES, DON'T MOVE CURSORDOTAB CLC ADC #1 PHA JSR DIVIDE AND TABS,X TAX PLA CPX #0 BNE OKTAB CMP LNMX BCC DOTABOKTAB STA PNTR RTS;CALBIT LDA PNTRDIVIDE PHA AND #7 TAY PLA LSR A LSR A LSR A TAX LDA #1SHFBIT DEY BMI ENDCAL ASL A JMP SHFBIT;; DO F2, SET TAB;DOF2 JSR CALBIT EOR TABS,X STA TABS,XENDCAL RTS;; DO F3, DELETE AFTER CURSOR;DOF3 JSR SCOLOR LDY PNTRNCLINR LDA #" " STA (PNT),Y LDA ROMSET+33 STA (USER),Y CPY LNMX INY BCC NCLINR RTS;; DO F4, DELETE BEFORE CURSOR;DOF4 JSR SCOLOR LDY PNTRNCLINL LDA #" " STA (PNT),Y LDA ROMSET+33 STA (USER),Y DEY BPL NCLINL RTS;; DO F5, INSERT MODE OFF;DOF5 LDA #$DF ; ISON^$FF AND FNBYTE STA FNBYTE RTS;; DO F6, INSERT MODE ON;DOF6 LDA FNBYTE ORA #ISON STA FNBYTE RTS;; DO F7, UPSIDEDOWN AND BACKWARDS HOME KEY;DOF7 LDX #0 LDY #24 STX PNTR STY TBLX JSR DOF8 JMP STUPT;; DO F8, ESCAPE KEY;DOF8 LDA #0 STA RVS ; CLEAR REVERSE FLAG STA QTSW ; NOT IN QUOTE MODE STA INSRT ; AND NO INSERTS OUTSTANDING RTS;LOCKUP LDA IBSOUT LDY IBSOUT+1 STA OBSOUT STY OBSOUT+1 LDA #<PRINT LDY #>PRINT BNE LOCKITLOCKCR LDA #<TBSOUT LDY #>TBSOUTLOCKIT STA IBSOUT STY IBSOUT+1 RTS;UNLOCK LDA OBSOUT LDY OBSOUT+1 STA IBSOUT STY IBSOUT+1 RTS;; LIST EDITOR LINE;FORLST JSR INCTR ; IGNORE LINK JSR LOADTR ; GET LINE NUMBER TAX ; SAVE IT JSR LOADTR JSR LINPRT ; NOW PRINT LINE NUMBER LDA #" " ; PRINT A SPACE AFTER JSR CHROUT LDA FNBYTE AND #SCRL ; CHECK FOR FORMAT BEQ FOR800 ; NO FORMAT, GO TO FOR800 LDX #0 ; ZERO COLUMN CTRFOR200 JSR LOADTR ; GET FIRST CHAR BEQ FOR100 ; END OF LINE? CMP #";" ; A COMMENT? BEQ FOR800 ; YES - NO TAB CMP #" " ; A SPACE? BEQ FOR300 ; YES JSR CHROUT ; NO - PRINT IT INX ; BUMP COLUMN CTR BNE FOR200 ; ALWAYS;FOR300 CPX #7 ; TAB TO COLUMN 8 BCS FOR400 ; YES JSR CHROUT ; NO - PRINT SPACE INX BNE FOR300 ; CONTINUE 'TILL A COLOUMN 8;FOR400 JSR LOADTR ; NEXT CHAR BEQ FOR100 ; END OF LINE CMP #" " ; A SPACE BEQ FOR400 ; YES - SKIP ITFOR500 JSR CHROUT ; NO - PRINT IT INX JSR LOADTR ; NEXT CHAR BEQ FOR100 ; END OF LINE CMP #"'" ; A QUOTE? BEQ FOR900 ; YES CMP #34 ; CHECK BOTH QUOTE TYPES BEQ FOR900 CMP #";" ; A COMMENT BNE FOR500 ; NO - THEN JUST PRINT IT PHA ; YES - SAVE CHAR LDA #" " ; A SPACEFOR600 CPX #23 ; TAB TO COLUMN 20 BCS FOR700 ; YES JSR CHROUT ; PRINT A SPACE INX BNE FOR600 ; ALWAYS;FOR700 PLA ; RESTORE CHARFOR800 JSR CHROUT ; PRINT IT JSR LOADTR ; NEXT CHAR BNE FOR800 ; END OF LINE?FOR100 LDA #CR ; YES, PRINT A RETURN JMP CHROUT;FOR900 STA QUTTYP ; SAVE QUOTE TYPEFOR999 JSR CHROUT ; PRINT IT INX ; KEEP TRACK OF TAB JSR LOADTR ; GET NEXT BYTE BEQ FOR100 ; END-OF-LINE? CMP QUTTYP ; COMPARE IF ITS A QUOTE BNE FOR999 ; IF NOT, JUST PRINT IT BEQ FOR500; .FILE EDITOR.6;;JSM - 04/24/84 COMMENT NEW BASIN ROUTINE;               ADD QUOTE TYPE FOR FORMAT ROUTINE AND COMMENT IT;JSM - 06/08/84 SWITCH INSERT MODE FUNTION KEYS;JSM - 09/25/84 ADD BLACKHOLE DELETE;               CHANGE LOAD/RUN FROM LOAD":*",8 TO LOAD":*