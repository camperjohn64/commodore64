 .PAGE "EDITOR.1";****************************************************;*                                                  *;*                      RTC EDITOR                  *;*                VERSION 2.2 SOURCE CODE           *;* COMMAND LIST FOR PART 1                          *;*                                                  *;* AUTO    AUTO INCREMENT VALUE                     *;* CLEAR   CLEAR ALL TABS                           *;* DELETE  DELETE LINE RANGE                        *;* FIND    FIND /STRING/,LINE RANGE                 *;* KILL    DISCONNECT WEDGE FROM BASIC              *;* CHANGE  CHANGE /FROM/TO/,LINE RANGE              *;*                                                  *;* PLUS - WEDGE INTO THE BASIC.                     *;*                                                  *;****************************************************; .LIB SYMBOLS .PAGE "RTC EDITOR"; JUMP=$4C ; JUMP COMMAND SKIP1=$24 ; BIT COMMAND TO SKIP ONE BYTE SKIP2=$2C ; BIT COMMAND TO SKIP TWO BYTES; RPLACE=$033C DRIVE=$033D DOSNAM=$033F ERRFIL=100 DSKFIL=101 PRTFIL=102; CR=13 ; RETURN CHARACTER CRSRDN=17 ; CURSOR DOWN KEY CRSRUP=145 ; CURSOR UP KEY SHRUN=131 ; SHIFT RUN DELKEY=20 ; DELETE KEY F1=133 ; FUNTION KEY DEFINITION F3=F1+1 F5=F3+1 F7=F5+1 F2=F7+1 F4=F2+1 F6=F4+1 F8=F6+1;;   FUNCTION BYTE; PASC=$80 ; BIT 7 - ASCII PRINTER LFON=$40 ; BIT 6 - LINE FEED ISON=$20 ; BIT 5 - INSERT SCRL=$10 ; BIT 4 - FORMATING SCROLL;; BIT 3 - UNUSED; BIT 2 - UNUSED; BIT 1 - UNUSED; BIT 0 - UNUSED;;         MONVAR; FN=$80 ; BIT 7 - FILE NAME SDR=$40 ; BIT 6 - DRIVE# PRG=$20 ; BIT 5 - PRG FILE SEQ=$10 ; BIT 4 - SEQ FILE REP=$08 ; BIT 3 - REPLACE USR=$04 ; BIT 2 - USR FILE UNIT=$02 ; BIT 1 - UNIT# RNG=$01 ; BIT 0 - RANGE;;***************************************************;*                                                 *;*        START OF EDITOR, ENABLE WEDGE CODE       *;*                                                 *;***************************************************; .IFE RELVER < *=$8000> .IFN RELVER < *=$8102>;BEGIN JMP SRT ; SKIP DEFINE BYTES FOR BOOT; .WORD ENDING-BEGIN ; DEFINE LENGTH OF EDITOR; .BYTE "22" ; VERSION NUMBER;SRT LDA #SCRL STA FNBYTE ; SET AUTO FORMAT LDY #0 STY AUTOLN ; CLEAR AUTO MODE TYA STA (TXTTAB),Y ; START OF BASIC INY STA (TXTTAB),Y ; START OF BASIC JSR CLRTAB ; CLEAR TABS LDA TXTTAB LDY TXTTAB+1 ADC #3 STA VARTAB BCC NOINY INYNOINY STY VARTAB+1 LDX #2 ; CHECK FOR ENABLE OR KILLAIDON LDA PATCH,X CMP CHRGET,X ;...BY CHECKING IF BNE EXEAID ; ALREADY ENABLED DEX BPL AIDON BMI STILON ; ALREADY ON;EXEAID JSR ENABLE ; NOT ON, ENABLE EDITORSTILON JMP NOTDEL;NMICOD PHA ; NMI VECTOR, SAVE REGISTERS TXA PHA TYA PHA LDA #$7F STA CI2ICR LDY CI2ICR ; CHECK FOR RS232 NMI REQUEST BMI RS232 JSR $F6BC JSR STOP ; STOP KEY PRESSED? BNE RS232 ; NO, MUST BE RS232 REQUEST JSR ENABLE JMP $FE69 ; CONTINUE WITH "BRK";RS232 JMP $FE72;ENABLE LDX #2 ; SET CHRGET ROUTINEDOENAB LDA PATCH,X STA CHRGET,X LDA RERUN,X ; AND KILL ROUTINE STA 700,X ; "SYS 700" TO KILL EDITOR DEX BPL DOENAB LDY IBASIN+1 ; CHECK IF I ALREADY ENABLED CPY #>BASIN ; ONLY CHECK HIGH BYTES BEQ DONTDO LDA IBASIN ; GET INPUT ROUTINE VECTOR STA JBASIN+1 ; SAVE IT FOR JMP STY JBASIN+2 LDA #<BASIN ;...AND SET NEW VECTOR LDY #>BASIN STA IBASIN STY IBASIN+1 LDA ILOAD ; GET NORMAL LOAD VECTOR LDY ILOAD+1 STA JLOAD+1 ; AND SAVE IT FOR JMP STY JLOAD+2 LDA #<LOADIT ; NOW PUT NEEW VECTOR LDY #>LOADIT STA ILOAD STY ILOAD+1 LDA ISAVE ; GET NORMAL SAVE VECTOR LDY ISAVE+1 STA JSAVE+1 ; AND SAVE IT FOR JMP STY JSAVE+2 LDA #<SAVEIT ; NOW PUT NEEW VECTOR LDY #>SAVEIT STA ISAVE STY ISAVE+1DONTDO LDA #<NMICOD ; SET NMI VECTOR LDY #>NMICOD STA NMINV STY NMINV+1 LDX #1 STX OLDFLG RTS;PATCH JMP TRCPRG ; FOR CHRGET ROUTINE;RERUN JMP BEGIN ; KILL ROUTINE AT 700;RSTART BNE KILL20 JMP (RESET);;****************************************************;*                                                  *;*              CLEAR ALL TABS COMMAND              *;*                                                  *;* SYNTAX: CLEAR                                    *;*                                                  *;****************************************************;CLTABS BNE KILL20 ; SYNTAX CHECK AFTER "CLEAR" JSR CLRTAB ; NOPE, CLEAR TABS JMP READY;CLRTAB LDY #9 ; CLEAR ALL TABS LDA #0TABCLR STA TABS,Y DEY BPL TABCLR; RTS;;****************************************************;*                                                  *;*                  DISABLE EDITOR                  *;*                                                  *;* SYNTAX: KILL                                     *;*                                                  *;****************************************************;KILL BEQ KILL10 ; CHECK FOR SYNTAXKILL20 JMP SYNTAX ; SYNTAX ERROR;KILL10 LDX #23 ; RESET CHRGET ROUTINEKILL11 LDA RELGET,X STA CHRGET,X DEX BPL KILL11; LDA JBASIN+1 ; RESET NORMAL INPUT ROUTINE LDY JBASIN+2 STA IBASIN STY IBASIN+1 LDA JLOAD+1 ; RESET NORMAL LOAD ROUTINE LDY JLOAD+2 STA ILOAD STY ILOAD+1 LDA JSAVE+1 ;...AND NORMAL SAVE ROUTINE LDY JSAVE+2 STA ISAVE STY ISAVE+1 JMP NOTDEL ; FIX END OF BASIC PTRS;; SAVE ALL REGISTERS;SAVREG STA WSW ; SAVE A PHP PLA STA T1 ; SAVE STATUS STX T2 ; SAVE X STY T3 ; SAVE Y RTS;; EDITOR VARIABLES;AUTOLN *=*+1 ; LINE INCREMENT NUMBERANDQUT ; QUOTE ANDING BYTEPAGNUM *=*+2 ; CURRENT PAGE# IN PLIST, TEMP.TABS *=*+10 ; TAB STOPSFNBYTE *=*+1 ; FUNCTION BYTEXSAVE *=*+1NSTART *=*+2 ; STARTING # FOR RENUMBER AFTER MOVENUMINC *=*+1 ; RENUMBER VALUE FOR AFTER MOVEVARBLE *=*+2OERROR *=*+2OBSOUT *=*+2OSTOP *=*+2OLDFLG *=*+1QUTTYP *=*+1 ; QUOTE TYPE, ' OR "LINOLD *=*+2OLDLTR *=*+2INST *=*+1;; RESTORE ALL REGISTERS;RESREG LDY T3 LDX T2 LDA T1 PHA LDA TXTPTR+1 CMP #2 BEQ PAR010 STA TMP2+1 LDA TXTPTR STA TMP2PAR010 LDA WSW PLP RTS;; WEDGE CODE INTERCEPTS SCAN CHARACTERS;WEDGE TSX ; SEE WHO CALLED CHRGET LDA STACK+1,X ; WAS IT MAIN CMP #<MAIN BNE RESREG ; NO LDA STACK+2,X ; MAYBE CMP #>MAIN BNE RESREG ; NO - EXIT WEDGE LDA #$FF ; SET DIRECT MODE STA CURLIN+1 LDA T1 ; GET STATUS BYTE LSR A ; WAS IT A NUMBER BCC WNUMB ; YES LDA #<CLIST ; SET POINTER TO COMMANDS STA INDEX1 LDA #>CLIST STA INDEX1+1 LDY #0 ; CHECK FOR EDITOR COMMAND STY COUNT ; ZERO INDEX INTO CMD ADDRESS DEY ; Y=FFPAR100 INY ; Y=0PAR150 LDX TXTPTR ; START AT BEGINPAR200 LDA BUF,X SEC ; DO CMP SBC (INDEX1),Y ; CHARACTERS THE SAME? BEQ PAR300 ; YES CMP #$80 ; SAME AND FOUND CMD? BEQ PAR400 ; YES INC COUNT ; NO - TRY NEXT LDY #0PAR250 LDA (INDEX1),Y ; SKIP RESET OF CMD NAME BMI PAR120 ; END OF CMD NAME JSR PAR130 ; NO - LOOK ON BNE PAR250 ; BRANCH ALWAYSPAR120 JSR PAR130 LDA (INDEX1),Y ; END OF CMD NAME TABLE BNE PAR150 ; NO - LOOK ON BEQ RESREG ; YES - NOT EDITOR COMMANDPAR300 INX ; MATCH TRY NEXT CHAR INY BNE PAR200 ; BRANCH ALWAYSPAR400 STX TXTPTR ; POINT TXTPTR AT LAST CHAR LDA COUNT ; FOUND CMD JMP TO IT ASL A ; ADRS ARE 2 BYTES TAX LDA CADR+1,X ; DO INDIRECT JMP PHA LDA CADR,X PHA JMP CHRGET;PAR130 INC INDEX1 ; NO - LOOK ON BNE RRTS1 INC INDEX1+1RRTS1 RTS;;****************************************************;*                                                  *;*                  AUTO LINE NUMBER                *;*  DISPLAY NEXT LINE NUMBER AFTER A RETURN ON A    *;* LINE.                                            *;*                                                  *;* SYNTAX: AUTO INCREMENT NUMBER                    *;*                                                  *;*  - TO TURN ON AUTO TYPE "AUTO" WITH AN INCREMENT *;*    VALUE.                                        *;*  - TO TURN OFF AUTO, JUST TYPE "AUTO" WITHOUT    *;*    AN INCREMENT VALUE.                           *;****************************************************;AUTO BEQ AUTOFF JSR EVL290 ; GET START # TXAAUTOFF STA AUTOLN JMP READY ; SAY READY;WNUMB PLA ; REMOVE JUNK FROM STACK PLA JSR RESREG ; RESTORE ALL REGISTERS JSR REDECN ; GET LINE # INTO LINNUM BCC WNB600 ; MAYBE A NUMBER JMP SYNTAX ; SYNTAX ERROR;WNB600 BEQ WNB900 ; LINE # ONLYWNB400 LDA AUTOLN ; IN AUTO MODE BEQ WNB900 ; NO LDA LINNUM ; LINE # FOR NEXT LINE CLC ADC AUTOLN STA FACMOH LDA LINNUM+1 ADC #0 STA FACHO JSR NUM280 LDX #0 ; PUT # IN KEYBOARDWNB700 LDA STACK+1,X ; BUFFER BEQ WNB800 ; DONE STA KEYD,X INX BNE WNB700 ; BRANCH ALWAYSWNB800 LDA #" " ; PUT IN EXTRA SPACE STA KEYD,X INX STX NDX ; X # CHAR'S IN BUFFER;; SQUISH LINE BY KILLING SPACES, DOESN'T KILL COMMENTS;WNB900 LDY #0 ; STOREING INDEXER STY ANDQUT+1 ; CLEAR COMMENT FLAG LDX #$FF ; LOADING INDEXER, X=-1COM100 INX ; INC FOR NEXT CHARACTER IN BUFFER LDA BUF,X ; SKIP SPACES CMP #" " BEQ COM100; .BYTE SKIP1 ; SKIP INXCOM200 INX LDA BUF,X ; SKIP NUMBERS CMP #"0" ; LESS THAN 0 BCC COM250 ; STOP SKIPING CMP #":" ; MORE THAN 9 BCC COM200 ; NO - A # SKIP ITCOM250 LDA BUF,X ; SKIP ONE MORE SPACE CMP #" " BNE NSPACCOM300 INXNSPAC LDA BUF,X ; CHECK FOR END-OF-LINE NULL BEQ COMEND BIT ANDQUT+1 ; TEST FOR COMMENT BMI SAVINB ; IN COMMENT, DON'T KILL SPACES CMP #" "        ; DON'T SKIP FIRST SPACE BNE SAVINB ; NOT A SPACE, SAVE ITCOM301 INX ; INC FOR NEXT CHARACTER LDA BUF,X CMP #" "        ; CHECK IF ITS A SPACE BEQ COM301 ; YES, KILL IT DEX ; DEX TO PLACE THIS ^ CHARACTER LDA #" " ;...PUT SPACE IN FIRSTSAVINB AND #%01111111 ; KILL ANY SHIFTED CHARACTERS STA BUF,Y CMP #";"        ; CHECK FOR A COMMENT BEQ COMNT ; YES,DON'T KILL ANY MORE SPACES CMP #34 ; CHECK IF ITS A QUOTE BEQ QUOTES CMP #"'" ; CHECK BOTH QUOTE TYPES BEQ QUOTES INY BNE COM300 ; ALWAYS;COMEND STA BUF,Y ; FIX FAKE LINK INY INY STA BUF,Y INY INY INY JMP INSERT+3 ; GO INSERT IT;COMNT DEC ANDQUT+1 ; SET COMMENT FLAG INY BNE COM300;QUOTES STA QUTTYP ; IN QUOTES, SAVE TYPE, ' OR " CMP #34 ; FULL QUOTE? BEQ FULQUT LDA #%01111111 ; NO, KILL BIT 7 .BYTE SKIP2 ; SKIP NEXT LDAFULQUT LDA #%11111111 ; FULL QUOTE ", KEEP ALL BITS STA ANDQUTQLP INX ; INC LOADING INDEXER INY ; INC STOREING INDEXER LDA BUF,X BEQ COMEND AND ANDQUT ; KILL OFF QUOTE BITS STA BUF,Y CMP QUTTYP ; WAIT 'TILL QUOTE FOUND AGAIN BNE QLP INY BNE COM300 ; ALWAYS BRANCH;;****************************************************;*                                                  *;*                    DELETE TEXT                   *;*  DELETE LINE OF BASIC TEXT WITHIN A SPECIFIED    *;* LINE RANGE.                                      *;*                                                  *;* SYNTAX: DELETE LINE RANGE                        *;*                                                  *;*  - LINE RANGE IS THE SAME AS LIST                *;*                                                  *;****************************************************;NRANGE JMP NORANG ; NO LINE RANGE ERROR;DELETE BEQ NRANGE ; BAD.. NO RANGE PARMS. JSR RANGE ; GET LINE # RANGE LDA LOWTR ; SAVE IT LDX LOWTR+1 STA INDEX2 STX INDEX2+1 JSR FNDLIN ; FIND IT BCC DEL300 ; SKIP IF NOT FOUNDDELTXT LDY #1 LDA (LOWTR),Y ; AT END OF PROGRAM BEQ DEL300 ; YES TAX DEY LDA (LOWTR),Y STA LOWTR ; INCLUDE IF NOT FOUND STX LOWTR+1DEL300 LDA INDEX2 ; CHECK FROM # < TO # SEC SBC LOWTR ; GEN NEG DELTA TAX LDA INDEX2+1 SBC LOWTR+1 TAY BCS NOTDEL TXA CLC ADC VARTAB ; GEN NEW END OF PROGRAM STA VARTAB TYA ADC VARTAB+1 STA VARTAB+1 LDY #0DEL500 LDA (LOWTR),Y ; MOVE PROGRAM DOWN STA (INDEX2),Y INY BNE DEL500 INC LOWTR+1 INC INDEX2+1 LDA VARTAB+1 ; DONE ONE EXTRA PAGE CMP INDEX2+1 BCS DEL500 ; NONOTDEL JSR LNKPRG CLC LDA INDEX1 ADC #2 STA VARTAB LDA INDEX1+1 ADC #0 STA VARTAB+1 JSR RUNCREADY LDX #0 STX PINFLG DEX STX CURLIN+1 JMP WARM ; SAY READY.;LOAD2 JSR LOADTR ; LOAD TWICELOADTR JSR INCTR ; INCREMENT FIRSTLOAD10 LDY #0 LDA (LOWTR),Y RTS;INCTR INC LOWTR BNE XRTS INC LOWTR+1XRTS RTS;GETSTR LDY TXTPTR ; START OF FIRST STRING INY STY STREND,X ; SET BEGIN OF STRING PTR LDA #0 STA STREND+1,X ; ZERO LENGTHFND190 LDA BUF,Y ; END BEQ FNDERR ; YES - GET OUT CMP T2 ; NO - DELIMITER PRINT BEQ STR010 ; YES INC STREND+1,X ; INC STRING LENGTH INY BNE FND190STR010 STY TXTPTR ; FIX TEXT PTR RTS;FNDERR JMP SYNTAX ; SYNTAX ERROR;;****************************************************;*                                                  *;*                FIND AND CHANGE TEXT              *;*                                                  *;*  SEARCH BASIC TEXT FOR A STRING AND DISPLAY IT.  *;*  SEARCH BASIC TEXT FOR A STRING, REPLACE IT WITH *;* A NEW STRING AND DISPLAY NEW LINE.               *;*                                                  *;* SYNTAX: FIND *STRING*,LINE RANGE                 *;*         CHANGE *OLD STRING*NEW STRING*,RANGE     *;*                                                  *;*  - ANY DELIMITER CAN BE USED TO ENCLOSE THE      *;*    STRING, SO LONG AS THE DELIMITER CHARACTER    *;*    DOES NOT APPEAR IN THE STRING.                *;*  - NOTE!  WHEN SEARCHING FOR STRINGS INSIDE OF   *;*    OF QUOTES OR "REMARKS" THE STRING MUST BE     *;*    ENCLOSED IN QUOTES.                           *;*  - NOTE! IF SEARCHING FOR QUOTES OR REMARKS DO   *;*    NOT US DELIMITERS THAT CAN BE TOKENIZED BY    *;*    BASIC.                                        *;*                                                  *;****************************************************;FIND LDA COUNT PHA JSR CHRGOT STA T2 ; SAVE DELIMITER LDA #JUMP ; SET JMP FOR FIND STA DOFIND LDX #0 JSR GETSTR ; READ FIRST STRING PLA ; RECALL COUNT CMP #4 ; TEST IF 5TH WORD IN TABLE BNE FND010 LDX #2 LDA #SKIP2 ; SET SKIP FOR CHANGE STA DOFIND JSR GETSTR ; READ 2ND STRINGFND010 JSR CHRGET ; MORE STUFF (RANGE) BEQ FND020 ; NO JSR CHKSPC ; REMOVE SPACES & CHECK COMMAFND020 JSR RANGE ; GET RANGE SET PTRS LDA #0 STA T1 LDA LOWTR STA TXTPTR LDA LOWTR+1 STA TXTPTR+1 JSR CRTN ; PRINT CR & LF BNE FND040 ; ALWAYS;FND030 LDY #0 LDA (LOWTR),Y TAX INY LDA (LOWTR),Y STA LOWTR+1 STA TXTPTR+1 STX TXTPTR STX LOWTRFND040 JSR HALT JSR CHRGT2 ; END OF PROGRAM BEQ FND050 ; YES - DONE JSR CHRGT2 STA INPPTR JSR CHRGT2 STA INPPTR+1 JSR TSTRNG BCC FND060 ; NOT DONEFND050 JMP NOTDEL ; FIX BASIC LINKS;FND060 STY SIZE ; SAVE PRESENT PTRFND070 INC SIZE ; BUMP PRESENT PTR LDY SIZE ; GET Y-REG. AGAIN LDX STREND ; START OF COMPAIR STRING LDA STREND+1 ; SET CMP CTR STA T2FND080 LDA (TXTPTR),Y ; END OF LINE BNE FND170 ; NO - CONTINUE BIT T1 BPL FND030 LDA LOWTR+1 PHA LDA LOWTR PHA LDA LINNUM+1 PHA LDA LINNUM PHA JSR LISTLN PLA STA LINNUM PLA STA LINNUM+1 PLA STA LOWTR PLA STA LOWTR+1 LDA #0 STA T1 BEQ FND030 ; DO NEXT LINE;FND170 CMP BUF,X ; MATCH BNE FND070 ; NO INX INY DEC T2 ; MATCHED ALL BNE FND080 ; NO DEY STY COUNT ; YES - SAVE LAST Y STY XSAVEDOFIND BIT FND150 ; GETS MODIFIED JSR FND260 ; SET BOTH INDEXS LDA FRETOP+1 ; CALC DIFF OF STRINGS SEC SBC STREND+1 STA T1 BEQ FND120 ; STRINGS EQUAL NO MOREFND090 INY BEQ FND050 ; 256 WRAP - GET OUT LDA (TXTPTR),Y ; END OF LINE BNE FND090 ; NO CLC TYA ADC T1 CMP #2 ; LINE TOO SHORT TO CHANGE BCC FND150 ; YES JUST PRINT CMP #251 ; LINE TOO L BCS FND150 ; YES LDA T1 ; SET PLUS/MINUS BPL FND100 ; NO BORROW DEC T2 ; HI BYTE NEG.FND100 CLC ADC COUNT ; CALC MOVE TO PTR STA XSAVE BCS FND110 ; A MOVE DOWN JSR FND310 ; MOVE UP BEQ FND120 ; BRANCH ALWAYS;FND110 JSR FND290FND120 LDA XSAVE ; CALC BEGIN OLD STRING SEC SBC FRETOP+1 TAY INY LDA FRETOP+1 BEQ FND140 ; NEW STRING EMPTY, SKIP STA T3 ; NEW STR CTR LDX FRETOP ; INDEX TO NEW STRINGFND130 LDA BUF,X ; GET NEW STR STA (TXTPTR),Y INX INY DEC T3 ; DONE BNE FND130FND140 CLC LDA VARTAB ; CALC NEW END OF MEMORY ADC T1 STA VARTAB LDA VARTAB+1 ADC T2 STA VARTAB+1FND150 LDA #$80 STA T1 JSR LNKPRG LDY XSAVE ; CONTINUE ON JMP FND060;FNDTXT LDA TXTPTR STA LOWTR LDA TXTPTR+1 STA LOWTR+1 RTS;FND260 LDA TXTPTR STA INDEX1 LDA TXTPTR+1 STA INDEX1+1 LDA VARTAB STA INDEX2 LDA VARTAB+1 STA INDEX2+1 RTS;FND270 LDA INDEX1 CMP INDEX2 BNE NRLOAD LDA INDEX1+1NRLOAD CMP INDEX2+1 RTS;FND300 JSR PAR130FND290 LDY COUNT INY LDA (INDEX1),Y LDY XSAVE INY STA (INDEX1),Y JSR FND270 BNE FND300 RTS;FND320 LDA INDEX2 BNE FND310 DEC INDEX2+1 DEC INDEX2FND310 LDY COUNT LDA (INDEX2),Y LDY XSAVE STA (INDEX2),Y JSR FND270 BNE FND320; RTS;; PRINT ERROR MESSAGES;SYNTAX LDX #1 ; SYNTAX ERROR .BYTE SKIP2NFOUND LDX #2 ; FILE NOT FOUND ERROR .BYTE SKIP2STRLNG LDX #3 ; STRING TO LONG ERROR .BYTE SKIP2NOLNTH LDX #4 ; ILLEGAL QUANTITY ERROR .BYTE SKIP2NORANG LDX #5 ; NO LINE RANGE ERROR .BYTE SKIP2LINEXT LDX #6 ; LINE EXSISTS ERROR .BYTE SKIP2NBASIC LDX #7 ; NOT BASIC ERROR .BYTE SKIP2NODEV LDX #8 ; DEVICE NOT PRESENT .BYTE SKIP2TOLONG LDX #9 ; LINE TOO LONG .BYTE SKIP2NOERR LDX #0 ; SET DIRECT MODE LDA #$FF STA CURLIN+1 DEX BPL ERROR1 JMP READY ; SAY READY;ERROR1 DEX BPL ERROR2 JMP SNERR ; SYNTAX ERROR;ERROR2 DEX BPL ERROR3 LDX #4 ; FILE NOT FOUND ERROR JMP PRTERR;ERROR3 DEX BPL ERROR4 LDX #$B0 ; STRING TO LONG ERROR JMP PRTERR;ERROR4 DEX BPL ERROR5 LDX #14 ; ILLEGAL QUANTITY ERROR JMP PRTERR;ERROR5 DEX BPL ERROR6 JSR PSTRM .BYTE 13,"?NO RANGE",0 JMP RERROR;ERROR6 DEX BPL ERROR7 JSR PSTRM .BYTE 13,"?LINE EXSITS",0 JMP RERROR;ERROR7 DEX BPL ERROR8 JSR PSTRM .BYTE 13,"?NOT BASIC",0 JMP RERROR;ERROR8 DEX BPL ERROR9 LDX #5 JMP PRTERR;ERROR9 DEX BPL NOERR JSR PSTRM .BYTE 13,"?LINE TOO LONG ERROR IN ",0 LDX LINNUM LDA LINNUM+1 JSR LINPRT JMP READY;RERROR JSR PSTRM .BYTE " ERROR",0 JMP READY;LOADIT JSR CHANGE ; DEFLAUT DEVICE IS 8JLOAD JMP $FFFF ; GETS MODIFIED;SAVEIT JSR CHANGE ; NEW SAVE VECTORJSAVE JMP $FFFF ; GETS MODIFIED;CHANGE LDX FA ; GET CURRENT DEVICE CPX #1 ; DID I DEFAULT TO TAPE? BNE NOTAPE ; NO, MUST BE OTHER DEVICE LDX #8 ; YES, DEFAULT TO DISK DRIVE STX FANOTAPE RTS; .FILE EDITOR.2;;JSM - 01/03/84 PROBLEM WITH CHANGE, CAN'T FIGURE IT OUT;JSM - 23/04/84 ADD LOAD/SAVE DEVICE EIGHT;JSM - 12/08/84 ADD INPUT LINE CRUNCH;JSM - 25/09/84 ADD LENGTH AND VERSION FOR BOOT;JSM - 04/06/85 GET RID OF 10 SYS FOR RELOCATOR;JSM - 04/06/85 FIX ?LINE EXSIST SOURCE ERROR