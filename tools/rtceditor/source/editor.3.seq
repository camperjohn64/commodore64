 .PAGE "EDITOR.3";****************************************************;*                                                  *;*                      RTC EDITOR                  *;*                                                  *;*  COMMAND LIST FOR PART 3                         *;*                                                  *;*  MOVE    NEW LOC.,LINE RANGE,START#,INC#         *;*  HEX     DEC, $HEX, OR %BINARY                   *;*  DISK    DOS EXPRESSION                          *;*  CATALOG EXPRESSION                              *;*                                                  *;****************************************************;;****************************************************;*                                                  *;*                     MOVE TEXT                    *;*                                                  *;*  TRANSFERS LINES OF BASIC CODE FROM ONE LOCATION *;* TO ANOTHER WITHIN A SPECIFED LINE RANGE.         *;*                                                  *;* SYNTAX: MOVE NEW LOCATION,LINE RANGE,START#,INC# *;*                                                  *;*  - NEW LOCATION IS THE POSITION WHERE THE BASIC  *;*    CODE IS TO BE MOVED.                          *;*  - LINE RANGE IS THE RANGE OF BASIC LINES TO BE  *;*    TRANSFERED.                                   *;*  - START# IS THE NUMBER THE FIRST LINE OF BASIC  *;*    IS GIVEN WHEN RENUMBERED.                     *;*  - INC# IS THE INCREMENT ADDED TO THE PREVIOUS   *;*    NUMBER TO CREATE THE NEXT LINE NUMBER         *;*                                                  *;*  - ALL PARIMITERS ARE NOT NEEDED                 *;*                                                  *;****************************************************;MOVE BNE MVE010MVE020 JMP SYNTAX ; SYNTAX ERROR;MVE010 JSR REDECN ; GET LINE NUMBER FOR LOCATION BCS MVE020 ; NOT A NUMBER (SYNTAX ERROR) LDA LINNUM STA PAGNUM LDA LINNUM+1 STA PAGNUM+1 JSR FNDLIN ; SEARCH FOR NEW LINE NUMBER BCC MVE030 JMP LINEXT ; LINE EXISTS ERROR;MVE030 JSR LOAD10 ; GET LO-BYTE OF LINE LINK STA FRESPC ; SAVE IT JSR LOADTR ; GET HI-BYTE OF LINE LINK ORA FRESPC ; SET A FLAG INDICATING WHERE THE STA FRESPC ; INSERTING IS TO TAKE PLACE JSR LOADTR ; GET LO-BYTE OF LINE NUMBER STA FRETOP ; SAVE IT JSR LOADTR ; GET HI-BYTE OF LINE NUMBER STA FRETOP+1 ; SAVE IT JSR CHKSPC ; REMOVE SPACES & CHECK COMMA JSR CHRGOT ; IS IT A NUMBER BCC MVE040 ; YES - GET 1ST NUMBER IN RANGE BNE MVE050 ; CHECK FOR A DASHMVERNG JMP NORANG ; NO LINE RANGE ERROR;MVE050 JSR CHKDSH ; REMOVE SPACES & CHECK DASH BCS MVERNGMVE040 JSR REDECN ; GET LINE NUMBER BCS MVE020 ; NUMBER > 63999 (SYNTAX ERROR) LDA LINNUM STA INPPTR LDA LINNUM+1 STA INPPTR+1 JSR FNDLIN ; FIND OR SET PTRS JSR CHRGOT ; GET LAST CHARACTER BEQ MVE060 ; SKIP REST IF DONE JSR CHKDSH ; REMOVE SPACES & CHECK DASH BCS MVE060 JSR CHRGET ; YES - SKIP IT JSR REDECN ; GET 2ND NUMBER BCS MVE020 ; NUMBER > 63999 (SYNTAX ERROR)MVE060 LDA LINNUM ; WAS A NUMBER ORA LINNUM+1 ; ENTERED BNE MVE070 ; YES - SAVE IT JSR MAXLIN ; SET LINE # TO 64000MVE070 LDA LINNUM CLC ADC #1 STA CURLIN LDA LINNUM+1 ADC #0 STA CURLIN+1 LDA #<1000 ; SET DEFAULT VALUES STA NSTART ; FOR RENUMBER LDA #>1000 ; STARTING AT 1000 STA NSTART+1 ; WITH INCREMENTS LDA #10 ; OF TEN STA NUMINC JSR CHRGOT ; RECALL CHARACTER BEQ MVE095 ; A TERMINATOR JSR CHKSPC ; NO - REMOVE SPACES & CHECK COMMA JSR CHRGOT JSR REDECN ; GET START NUMBER FOR RENUMBER BCS MVESYN ; NUMBER > 63999 (SYNTAX ERROR) LDX LINNUM STX NSTART LDX LINNUM+1 STX NSTART+1 TAX BEQ MVE095 JSR CHKSPC ; REMOVE SPACES & CHECK COMMA JSR CHRGOT JSR REDECN ; GET INCREMENT VALUE FOR RENUMBER BCS MVESYN ; NUMBER > 63999 (SYNTAX ERROR) LDA LINNUM+1 BEQ MVE100MVE110 JMP NOLNTH ; ILLEGAL QUANTITY ERROR;MVESYN JMP SYNTAX ; SYNTAX ERROR;MVE100 LDA LINNUM BEQ MVE110 STA NUMINC;; CHECK IF MOVE WITH ITSELF;MVE095 LDA VARTAB STA ARYTAB LDA VARTAB+1 STA ARYTAB+1 LDA PAGNUM STA LINNUM LDA PAGNUM+1 STA LINNUM+1 JSR TSTRNG BCS MVE280 BVS MVE280 JMP NOLNTH;; CHECK RANGE FOR RENUMBER;MVE280 LDA TXTTAB STA INDEX1 LDA TXTTAB+1 STA INDEX1+1 LDA NSTART STA LINNUM LDA NSTART+1 STA LINNUM+1MVE300 LDA INDEX1 ORA INDEX1+1 BEQ MVE400 JSR INDEX CLC LDA LINNUM ADC NUMINC STA LINNUM BCC MVE290 INC LINNUM+1MVE290 LDA LINNUM CMP #<64000 LDA LINNUM+1 SBC #>64000 BCC MVE300 JMP NOLNTH;MVE400 LDA LOWTR STA INDEX1 LDA LOWTR+1 STA INDEX1+1MVE410 LDA INDEX1 ORA INDEX1+1 BEQ MVE090 LDY #2 LDA (INDEX1),Y STA LINNUM INY LDA (INDEX1),Y STA LINNUM+1 JSR CHKIT BCS MVE090MVE420 INY LDA (INDEX1),Y BNE MVE420 CPY #$55 JSR INDEX BCC MVE410 JMP TOLONG ; LINE TOO LONG;MVE090 LDA ARYTAB STA VARTAB LDA ARYTAB+1 STA VARTAB+1 JSR LOAD10 ; GET LO-BYTE OF LINE LINK STA FRESPC+1 ; FOR 1ST LINE IN RANGE JSR LOADTR ; GET HI-BYTE OF LINE LINK ORA FRESPC+1 ; TEST IF END OF BASIC BNE MVE120 ; NO - START MOVING TEXTDRENUM LDA NSTART ; YES - SET START NUMBER STA FRESPC ; AND INCREMENT VALUES LDA NSTART+1 ; FOR RENUMBER STA FRESPC+1 LDA NUMINC STA FRETOP JSR ZERO ; RENUMBER LINE RANGE JMP GONUM ; START RENUMBERING PROGRAM;MVE120 JSR LOADTR ; GET LO-BYTE OF LINE NUMBER STA LINNUM JSR LOADTR ; GET HI-BYTE OF LINE NUMBER STA LINNUM+1 JSR LOADTR JSR CHKIT BCS DRENUM;; TRANSFER LINE INTO BASIC INPUT BUFFER; LDY #$FFMVE130 INY LDA (LOWTR),Y STA BUF,Y BNE MVE130 INY;; INDEX2 POINTS TO BEGINING OF LINE TO BE DELETED; SEC LDA LOWTR SBC #4 STA INDEX2 LDA LOWTR+1 SBC #0 STA INDEX2+1;; CALC. END OF LINE TO BE DELETED; TYA CLC ADC LOWTR STA INDEX1 LDA LOWTR+1 ADC #0 STA INDEX1+1;; SAVE SEARCH LINE NUMBER; LDY #2 LDA (INDEX1),Y STA PAGNUM INY LDA (INDEX1),Y STA PAGNUM+1;; DELETE LINE FROM TEXT; LDY #0MVE160 LDA (INDEX1),Y STA (INDEX2),Y INC INDEX2 BNE NIDEX INC INDEX2+1NIDEX JSR PAR130;; FINISHED DELETE; LDA VARTAB CMP INDEX1 LDA VARTAB+1 SBC INDEX1+1 BCS MVE160 LDA INDEX2 BNE NIINX DEC INDEX2+1NIINX DEC INDEX2 LDA FRESPC BNE MVE170;; TACK TRANSFERED LINE ONTO END OF PROGRAM; SEC LDA INDEX2 SBC #2 STA INDEX1 LDA INDEX2+1 SBC #0 STA INDEX1+1 JMP MVE191;; FIND DESTINATION POINT;MVE170 LDA TXTTAB STA INDEX1 LDA TXTTAB+1 STA INDEX1+1MVE210 LDY #2 LDA (INDEX1),Y CMP FRETOP BNE MVE180 INY LDA (INDEX1),Y CMP FRETOP+1 BEQ MVE190MVE180 JSR PAR130 JSR PAR130 JSR PAR130MVE200 JSR PAR130 LDY #0 LDA (INDEX1),Y BNE MVE200 JSR PAR130 BNE MVE210;; OPEN SPACE IN MEMORY FOR LINE;MVE190 LDY #0 LDA (INDEX2),Y STA (VARTAB),Y LDA VARTAB BNE MVE220 DEC VARTAB+1MVE220 DEC VARTAB LDA INDEX2 BNE MVE230 DEC INDEX2+1MVE230 DEC INDEX2 LDA INDEX2 CMP INDEX1 LDA INDEX2+1 SBC INDEX1+1 BCS MVE190;; INSERT TRANSFERED LINE INTO TEXT;MVE191 LDA #1 ; SAVE DUMMY LINE LINKS STA (INDEX1),Y INY STA (INDEX1),Y INY LDA LINNUM ; SAVE LINE NUMBER STA (INDEX1),Y INY LDA LINNUM+1 STA (INDEX1),YMVE240 INY ; READ LINE FROM TAPE BUF LDA BUF-4,Y ; INTO MEMORY STA (INDEX1),Y ; SAVE BYTE BNE MVE240 ; END OF LINEMVE250 JSR LNKPRG ; RE-LINK PROGRAM LDA TXTTAB STA INDEX1 LDA TXTTAB+1 STA INDEX1+1 BNE MVE260;MVE270 JSR INDEXMVE260 LDY #2 LDA (INDEX1),Y CMP PAGNUM BNE MVE270 INY LDA (INDEX1),Y CMP PAGNUM+1 BNE MVE270 LDA INDEX1 STA LOWTR LDA INDEX1+1 STA LOWTR+1 JMP MVE090;CHKIT LDA LINNUM CMP CURLIN LDA LINNUM+1 SBC CURLIN+1 RTS;INDEX LDY #0 LDA (INDEX1),Y TAX INY LDA (INDEX1),Y STA INDEX1+1 STX INDEX1 RTS;CHKSPC JSR CHRGOTTSTSPC CMP #" " BNE NOTSPC JSR CHRGET JMP TSTSPC;NOTSPC JMP CHKCOM;;****************************************************;*                                                  *;*                        HEX                       *;*                                                  *;*  CONVERT DECIMAL, HEXADECIMAL, & BINARY NUMBERS  *;* TO HEXADECIMAL AND DECIMAL EQUIVILANTS.          *;*                                                  *;* SYNTAX: HEX DECIMAL#, $HEXADECIMAL#, OR %BINARY  *;*                                                  *;* - ADDITION AND SUBTRACTION OF THE SAME OR        *;*   DIFFERENT BASES MAY BE DONE.                   *;*                                                  *;****************************************************;HEX LDX #0 STX COUNT STX TMP2 STX TMP2+1 CMP #"%" BEQ HEXLOP CMP #"$" BEQ HEXLOP TAX BNE HEXLOPHEXERR JMP SYNTAX ; SYNTAX ERROR;HEXLOP JSR HEXDEC ; READ A NUMBER PHP LDA COUNT CMP #2 BCS HEX090 LDA LINNUM STA TMP2 LDA LINNUM+1 STA TMP2+1HEX090 PLP BCS HEXPRT ; END OF CONVERTION JSR CHRGOT CMP #"+" BNE HEX030 JSR CHRGET JSR HEXDEC ; READ A NUMBER PHP CLCHEX095 LDA TMP2 ADC LINNUM STA TMP2 LDA TMP2+1 ADC LINNUM+1 STA TMP2+1 PLP BCS HEXPRT BCC HEXLOP;HEX030 CMP #"-" ; A MINUS SIGN BNE HEXERR ; SYNTAX ERROR JSR CHRGET JSR HEXDEC ; READ A NUMBER PHP LDA LINNUM EOR #$FF STA LINNUM LDA LINNUM+1 EOR #$FF STA LINNUM+1 SEC BCS HEX095;HEXPRT LDA TMP2 ; SHOVE NUMBER IN "LINNUM" STA LINNUM LDA TMP2+1 STA LINNUM+1 LDA #CR ; PRINT RETURN FIRST JSR PRINTHPRT01 JSR PRTHEX ; PRINT HEX # LDA #"=" JSR PRINT LDA #"%" ; NOW PRINT BINARY DIGIT JSR PRINT LDA LINNUM+1 ; SAVE NUMBER ON STACK PHA LDA LINNUM PHA LDX #15NXTBIT JSR ROTBIT ; ROTATE BITS LDA #"0" ; GET ASCII NUMBER ZERO ADC #0 ; ADD CARRY FROM ROTATING BITS JSR PRINT ; PRINT IT DEX ; DEX FOR NEXT BIT BPL NXTBIT ; NOT DONE ALL BITS YET LDA #"=" JSR PRINT PLA ; GET SAVED NUMBER AGAIN TAX PLA JSR LINPRT ;...AND PRINT IT IN DECIMAL LDA #13 JSR PRINT JMP READY ; SAY READY.;PRTNUM LDA LINNUM+1 ; PRINT DECIMAL NUMBER LDX LINNUMNUMPRT JSR CRS420 LDX #0NXTDIG LDA STACK,X BEQ NODIG JSR PRINT INX BNE NXTDIGNODIG RTS;HEXBIT JSR ROTBIT JSR ROTBIT JSR ROTBITBINBIT JSR ROTBIT ORA LINNUM STA LINNUM RTS;ROTBIT ASL LINNUM ROL LINNUM+1 RTS;CRS420 STA FACHO STX FACMOHNUM280 LDX #$90 SEC JSR FLOATC JMP BINASC;REDECN PHA JSR LINZRO STA PTR1 PLA BEQ RED010RED020 JSR TSTNUM ; IS IT A NUMBER BCS RED010 ; NO EXIT ROUTINE SBC #$2F STA GARBFL LDA LINNUM+1 STA INDEX1 CMP #$19 BCC RED110 LDA #$80 STA PTR1RED110 LDA LINNUM ASL A ROL INDEX1 ASL A ROL INDEX1 ADC LINNUM STA LINNUM LDA INDEX1 ADC LINNUM+1 STA LINNUM+1 JSR ROTBIT LDA LINNUM ADC GARBFL STA LINNUM BCC RED900 INC LINNUM+1RED900 JSR CHRGT2 BNE RED020 ; ALWAYSRED010 BIT PTR1 BPL RED030 SEC .BYTE SKIP1RED030 CLC JMP CHRGO2;PRTHEX JSR PSTRM ; PRINT HEX DIGIT .BYTE " $",0 LDA LINNUM STA MONVAR LDA LINNUM+1 STA MONVAR+1 JMP HEXOUT;HEXDEC JSR CHRGOT BEQ DEC010 CMP #"%" BEQ BINARY CMP #"$" ; A HEX NUMBER BNE DECNUM JSR LINZROREH010 JSR CHRGET CMP #"0" BCC REH020 CMP #"G" BCS BINERR AND #$CF CMP #10 BMI *+4 SBC #7 AND #$F JSR HEXBIT BCS BINERR BCC REH010REH020 JMP DECEXT;DECNUM JSR REDECN ; READ DEC NUMBERDECEXT INC COUNT JSR CHRGOT BEQ DEC010 CLC .BYTE SKIP1DEC010 SEC RTS;BINARY JSR LINZROBIN010 JSR CHRGET CMP #"0" BCC BIN020 CMP #"2" BCS BINERR AND #1 JSR BINBIT BCC BIN010BINERR JMP SYNTAX;BIN020 JMP DECEXT;LINZRO LDA #0 STA LINNUM+1 STA LINNUM RTS;MAXLIN LDA #>64000 STA LINNUM+1 LDA #<64000 STA LINNUM RTS;;****************************************************;*                                                  *;*                   DISK OR DOS                    *;*                                                  *;*  SEND DISK COMMANDS AND CHECK ERROR CHANNEL.     *;*                                                  *;* SYNTAX: DOS "DOS EXPRESSION"                     *;*         DISK "DOS EXPRESSION"                    *;*                                                  *;* - COMMAND IN QUOTES, UNIT#, DRIVE#, ETC.         *;*                                                  *;****************************************************;DISK JSR EVLDOS AND #%00110101 BNE DSKERR JSR CRTN LDA #<DOSNAM STA FNADR DEC FNLEN DEC FNLEN LDA #ERRFIL STA LA LDA #15 STA SA JSR OPEN BCS DSK010 LDX #ERRFIL JSR CHKINDISK30 JSR GETIN ; GET CHAR. FROM IEEE JSR PRINT CMP #CR BNE DISK30 JSR ABORT JMP READY ; SAY READY;DSKERR JMP SYNTAX;DSK010 JSR ABORT JMP NODEV;;****************************************************;*                                                  *;*               CATALOG OR DIRECTORY               *;*                                                  *;* READ DIRECTORY OF DISK AND DISPLAY IT TO SCREEN  *;*                                                  *;* SYNTAX: CATALOG "EXPRESSION",DRIVE               *;*         DIRECTORY "EXPRESSION",DRIVE             *;*                                                  *;* - PATTERN MATCHING IN QUOTES, DRIVE#, UNIT#, ETC.*;*                                                  *;****************************************************;DIRECT JSR EVLDOS AND #%00110101 BNE DSKERR BIT MONVAR LDX #1 LDA #"$" STA DRIVE-1 CPX #3 BCC NOINX INXNOINX STX FNLEN CPX #20 BCC NTLONG JMP STRLNG ; STRING TO LONG ERROR;NTLONG LDA #<DRIVE-1 STA FNADR JSR SAVOUT LDA #DSKFIL ; LOGICAL FILE NUMBER LDX FA ; GET UNIT NUMBER LDY #0 ; CHANNEL ZERO JSR SETLFS JSR OPEN ; OPEN RETURN CHANNEL BCS DSK010 LDX #DSKFIL ; SET INPUT DEVICE JSR CHKIN LDY #3 ; LOOP THREE TIMESDIR130 STY FNLEN ; SAVE NEW COUNT BCS DIR120 JSR GETIN ; GET BYTE STA TMP2 LDY STATUS ; CHECK STATUS BNE DIR120 JSR GETIN ; GET NEXT BYTE STA TMP2+1 LDY STATUS ; CHECK STATUS AGAIN BNE DIR120 LDY FNLEN ; MORE TO DO DEY BNE DIR130 ; NOT DONE YET LDA #3 ; SET OUTPUT TO SCREEN STA DFLTO LDX TMP2 LDA TMP2+1 JSR LINPRT ; PRINT FIXED POINT VALUE LDA #DSKFIL STA DFLTO LDA #" " ; PRINT A SPACE JSR PRINTDIR140 JSR GETIN ; GET BYTE LDX STATUS BNE DIR120 ; CHECK STATUS TAX ; END-OF-LINE BEQ DIR150 JSR PRINT ; PRINT CHARACTER LDA #0 ; SET INPUT FROM KEYBOURD STA DFLTN JSR HALT ; CHECK SPACE OR STOP KEY LDA #DSKFIL ; RESET INPUT FROM DEVICE STA DFLTN JMP DIR140;DIR150 LDA #CR JSR PRINT ; PRINT A RETURN LDY #2 ; SET COUNT BNE DIR130 ; ALWAYS;DIR120 JSR ABORT JSR SETOUT ; SET OUTPUT DEVICE JMP READY ; SAY READY;OUTCHR JSR SETOUT JSR CHROUT JMP CLRCHN;SETOUT LDX OUTDEV CPX #3 BEQ SET010 PHA LDX OUTFIL JSR CHKOUT PLA RTS;OUTDEV *=*+1OUTFIL *=*+1;SAVOUT LDA LA STA OUTFIL LDA DFLTO STA OUTDEVSET010 RTS;SETLIN LDA LINNUM LDY LINNUM+1 STA STACK+$FE STY STACK+$FF RTS; .FILE EDITOR.4;JSM - 04/06/85 MAKE CATALOG NOT NEED DRIVE NUMBER